// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::sdk::*;
use crate::sdk_builder::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -723066633;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__sdk__BreezSdk_add_event_listener_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_add_event_listener",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_listener = <StreamSink<
                crate::events::SdkEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::sdk::BreezSdk::add_event_listener(
                                &*api_that_guard,
                                api_listener,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_check_lightning_address_available_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_check_lightning_address_available",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::CheckLightningAddressRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::check_lightning_address_available(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_claim_deposit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_claim_deposit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ClaimDepositRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::claim_deposit(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_delete_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_delete_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::delete_lightning_address(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::disconnect(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::GetInfoRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_info(&*api_that_guard, api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_lightning_address(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::GetPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_tokens_metadata_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_tokens_metadata",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::GetTokensMetadataRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::get_tokens_metadata(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_fiat_currencies_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_fiat_currencies",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_fiat_currencies(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_fiat_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_fiat_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_fiat_rates(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ListPaymentsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_payments(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_unclaimed_deposits_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_unclaimed_deposits",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::ListUnclaimedDepositsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::list_unclaimed_deposits(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_lnurl_pay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_lnurl_pay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::LnurlPayRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::lnurl_pay(&*api_that_guard, api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_prepare_lnurl_pay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_prepare_lnurl_pay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::PrepareLnurlPayRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::prepare_lnurl_pay(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_prepare_send_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_prepare_send_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::PrepareSendPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::prepare_send_payment(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_receive_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_receive_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ReceivePaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::receive_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_refund_deposit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_refund_deposit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::RefundDepositRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::refund_deposit(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_register_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_register_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::RegisterLightningAddressRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::register_lightning_address(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_remove_event_listener_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_remove_event_listener",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::sdk::BreezSdk::remove_event_listener(&*api_that_guard, &api_id)
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_send_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_send_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::SendPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::send_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_sync_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_sync_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::SyncWalletRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::sync_wallet(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_wait_for_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_wait_for_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::WaitForPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::wait_for_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk_builder::SdkBuilder::build(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_config = <crate::models::Config>::sse_decode(&mut deserializer);
            let api_seed = <crate::models::Seed>::sse_decode(&mut deserializer);
            let api_storage = <Arc<dyn Storage>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::new(
                    api_config,
                    api_seed,
                    api_storage,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_with_key_set_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_with_key_set",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <SdkBuilder>::sse_decode(&mut deserializer);
            let api_key_set_type = <crate::models::KeySetType>::sse_decode(&mut deserializer);
            let api_use_address_index = <bool>::sse_decode(&mut deserializer);
            let api_account_number = <Option<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::with_key_set(
                    api_that,
                    api_key_set_type,
                    api_use_address_index,
                    api_account_number,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_with_rest_chain_service_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_with_rest_chain_service",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <SdkBuilder>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_credentials =
                <Option<crate::models::Credentials>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::with_rest_chain_service(
                        api_that,
                        api_url,
                        api_credentials,
                    ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_request = <crate::models::ConnectRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let output_ok = crate::sdk::connect(api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__default_config_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "default_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::models::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::sdk::default_config(api_network))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__default_storage_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "default_storage",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::errors::SdkError>((move || {
                let output_ok = crate::sdk::default_storage(api_data_dir)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__init_logging_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_logging",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_log_dir = <Option<String>>::sse_decode(&mut deserializer);
            let api_app_logger = <StreamSink<
                crate::logger::LogEntry,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_log_filter = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::errors::SdkError>((move || {
                let output_ok =
                    crate::sdk::init_logging(api_log_dir, api_app_logger, api_log_filter)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__parse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let output_ok = crate::sdk::parse(&api_input).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let AesSuccessActionData = None::<crate::models::AesSuccessActionData>.unwrap();
        let _: String = AesSuccessActionData.description;
        let _: String = AesSuccessActionData.ciphertext;
        let _: String = AesSuccessActionData.iv;
    }
    {
        let AesSuccessActionDataDecrypted =
            None::<crate::models::AesSuccessActionDataDecrypted>.unwrap();
        let _: String = AesSuccessActionDataDecrypted.description;
        let _: String = AesSuccessActionDataDecrypted.plaintext;
    }
    match None::<crate::models::AesSuccessActionDataResult>.unwrap() {
        crate::models::AesSuccessActionDataResult::Decrypted { data } => {
            let _: crate::models::AesSuccessActionDataDecrypted = data;
        }
        crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
            let _: String = reason;
        }
    }
    match None::<crate::models::Amount>.unwrap() {
        crate::models::Amount::Bitcoin { amount_msat } => {
            let _: u64 = amount_msat;
        }
        crate::models::Amount::Currency {
            iso4217_code,
            fractional_amount,
        } => {
            let _: String = iso4217_code;
            let _: u64 = fractional_amount;
        }
    }
    match None::<crate::models::AssetFilter>.unwrap() {
        crate::models::AssetFilter::Bitcoin => {}
        crate::models::AssetFilter::Token { token_identifier } => {
            let _: Option<String> = token_identifier;
        }
    }
    {
        let Bip21Details = None::<crate::models::Bip21Details>.unwrap();
        let _: Option<u64> = Bip21Details.amount_sat;
        let _: Option<String> = Bip21Details.asset_id;
        let _: String = Bip21Details.uri;
        let _: Vec<crate::models::Bip21Extra> = Bip21Details.extras;
        let _: Option<String> = Bip21Details.label;
        let _: Option<String> = Bip21Details.message;
        let _: Vec<crate::models::InputType> = Bip21Details.payment_methods;
    }
    {
        let Bip21Extra = None::<crate::models::Bip21Extra>.unwrap();
        let _: String = Bip21Extra.key;
        let _: String = Bip21Extra.value;
    }
    {
        let BitcoinAddressDetails = None::<crate::models::BitcoinAddressDetails>.unwrap();
        let _: String = BitcoinAddressDetails.address;
        let _: crate::models::BitcoinNetwork = BitcoinAddressDetails.network;
        let _: crate::models::PaymentRequestSource = BitcoinAddressDetails.source;
    }
    {
        let Bolt11Invoice = None::<crate::models::Bolt11Invoice>.unwrap();
        let _: String = Bolt11Invoice.bolt11;
        let _: crate::models::PaymentRequestSource = Bolt11Invoice.source;
    }
    {
        let Bolt11InvoiceDetails = None::<crate::models::Bolt11InvoiceDetails>.unwrap();
        let _: Option<u64> = Bolt11InvoiceDetails.amount_msat;
        let _: Option<String> = Bolt11InvoiceDetails.description;
        let _: Option<String> = Bolt11InvoiceDetails.description_hash;
        let _: u64 = Bolt11InvoiceDetails.expiry;
        let _: crate::models::Bolt11Invoice = Bolt11InvoiceDetails.invoice;
        let _: u64 = Bolt11InvoiceDetails.min_final_cltv_expiry_delta;
        let _: crate::models::BitcoinNetwork = Bolt11InvoiceDetails.network;
        let _: String = Bolt11InvoiceDetails.payee_pubkey;
        let _: String = Bolt11InvoiceDetails.payment_hash;
        let _: String = Bolt11InvoiceDetails.payment_secret;
        let _: Vec<crate::models::Bolt11RouteHint> = Bolt11InvoiceDetails.routing_hints;
        let _: u64 = Bolt11InvoiceDetails.timestamp;
    }
    {
        let Bolt11RouteHint = None::<crate::models::Bolt11RouteHint>.unwrap();
        let _: Vec<crate::models::Bolt11RouteHintHop> = Bolt11RouteHint.hops;
    }
    {
        let Bolt11RouteHintHop = None::<crate::models::Bolt11RouteHintHop>.unwrap();
        let _: String = Bolt11RouteHintHop.src_node_id;
        let _: String = Bolt11RouteHintHop.short_channel_id;
        let _: u32 = Bolt11RouteHintHop.fees_base_msat;
        let _: u32 = Bolt11RouteHintHop.fees_proportional_millionths;
        let _: u16 = Bolt11RouteHintHop.cltv_expiry_delta;
        let _: Option<u64> = Bolt11RouteHintHop.htlc_minimum_msat;
        let _: Option<u64> = Bolt11RouteHintHop.htlc_maximum_msat;
    }
    {
        let Bolt12Invoice = None::<crate::models::Bolt12Invoice>.unwrap();
        let _: String = Bolt12Invoice.invoice;
        let _: crate::models::PaymentRequestSource = Bolt12Invoice.source;
    }
    {
        let Bolt12InvoiceDetails = None::<crate::models::Bolt12InvoiceDetails>.unwrap();
        let _: u64 = Bolt12InvoiceDetails.amount_msat;
        let _: crate::models::Bolt12Invoice = Bolt12InvoiceDetails.invoice;
    }
    {
        let Bolt12InvoiceRequestDetails =
            None::<crate::models::Bolt12InvoiceRequestDetails>.unwrap();
    }
    {
        let Bolt12Offer = None::<crate::models::Bolt12Offer>.unwrap();
        let _: String = Bolt12Offer.offer;
        let _: crate::models::PaymentRequestSource = Bolt12Offer.source;
    }
    {
        let Bolt12OfferBlindedPath = None::<crate::models::Bolt12OfferBlindedPath>.unwrap();
        let _: Vec<String> = Bolt12OfferBlindedPath.blinded_hops;
    }
    {
        let Bolt12OfferDetails = None::<crate::models::Bolt12OfferDetails>.unwrap();
        let _: Option<u64> = Bolt12OfferDetails.absolute_expiry;
        let _: Vec<String> = Bolt12OfferDetails.chains;
        let _: Option<String> = Bolt12OfferDetails.description;
        let _: Option<String> = Bolt12OfferDetails.issuer;
        let _: Option<crate::models::Amount> = Bolt12OfferDetails.min_amount;
        let _: crate::models::Bolt12Offer = Bolt12OfferDetails.offer;
        let _: Vec<crate::models::Bolt12OfferBlindedPath> = Bolt12OfferDetails.paths;
        let _: Option<String> = Bolt12OfferDetails.signing_pubkey;
    }
    {
        let CheckLightningAddressRequest =
            None::<crate::models::CheckLightningAddressRequest>.unwrap();
        let _: String = CheckLightningAddressRequest.username;
    }
    {
        let ClaimDepositRequest = None::<crate::models::ClaimDepositRequest>.unwrap();
        let _: String = ClaimDepositRequest.txid;
        let _: u32 = ClaimDepositRequest.vout;
        let _: Option<crate::models::Fee> = ClaimDepositRequest.max_fee;
    }
    {
        let ClaimDepositResponse = None::<crate::models::ClaimDepositResponse>.unwrap();
        let _: crate::models::Payment = ClaimDepositResponse.payment;
    }
    {
        let Config = None::<crate::models::Config>.unwrap();
        let _: Option<String> = Config.api_key;
        let _: crate::models::Network = Config.network;
        let _: u32 = Config.sync_interval_secs;
        let _: Option<crate::models::Fee> = Config.max_deposit_claim_fee;
        let _: Option<String> = Config.lnurl_domain;
        let _: bool = Config.prefer_spark_over_lightning;
    }
    {
        let ConnectRequest = None::<crate::models::ConnectRequest>.unwrap();
        let _: crate::models::Config = ConnectRequest.config;
        let _: crate::models::Seed = ConnectRequest.seed;
        let _: String = ConnectRequest.storage_dir;
    }
    {
        let Credentials = None::<crate::models::Credentials>.unwrap();
        let _: String = Credentials.username;
        let _: String = Credentials.password;
    }
    {
        let CurrencyInfo = None::<crate::models::CurrencyInfo>.unwrap();
        let _: String = CurrencyInfo.name;
        let _: u32 = CurrencyInfo.fraction_size;
        let _: Option<u32> = CurrencyInfo.spacing;
        let _: Option<crate::models::Symbol> = CurrencyInfo.symbol;
        let _: Option<crate::models::Symbol> = CurrencyInfo.uniq_symbol;
        let _: Vec<crate::models::LocalizedName> = CurrencyInfo.localized_name;
        let _: Vec<crate::models::LocaleOverrides> = CurrencyInfo.locale_overrides;
    }
    match None::<crate::errors::DepositClaimError>.unwrap() {
        crate::errors::DepositClaimError::DepositClaimFeeExceeded {
            tx,
            vout,
            max_fee,
            actual_fee,
        } => {
            let _: String = tx;
            let _: u32 = vout;
            let _: crate::models::Fee = max_fee;
            let _: u64 = actual_fee;
        }
        crate::errors::DepositClaimError::MissingUtxo { tx, vout } => {
            let _: String = tx;
            let _: u32 = vout;
        }
        crate::errors::DepositClaimError::Generic { message } => {
            let _: String = message;
        }
    }
    {
        let DepositInfo = None::<crate::models::DepositInfo>.unwrap();
        let _: String = DepositInfo.txid;
        let _: u32 = DepositInfo.vout;
        let _: u64 = DepositInfo.amount_sats;
        let _: Option<String> = DepositInfo.refund_tx;
        let _: Option<String> = DepositInfo.refund_tx_id;
        let _: Option<crate::errors::DepositClaimError> = DepositInfo.claim_error;
    }
    match None::<crate::models::Fee>.unwrap() {
        crate::models::Fee::Fixed { amount } => {
            let _: u64 = amount;
        }
        crate::models::Fee::Rate { sat_per_vbyte } => {
            let _: u64 = sat_per_vbyte;
        }
    }
    {
        let FiatCurrency = None::<crate::models::FiatCurrency>.unwrap();
        let _: String = FiatCurrency.id;
        let _: crate::models::CurrencyInfo = FiatCurrency.info;
    }
    {
        let GetInfoRequest = None::<crate::models::GetInfoRequest>.unwrap();
        let _: Option<bool> = GetInfoRequest.ensure_synced;
    }
    {
        let GetInfoResponse = None::<crate::models::GetInfoResponse>.unwrap();
        let _: u64 = GetInfoResponse.balance_sats;
        let _: std::collections::HashMap<String, crate::models::TokenBalance> =
            GetInfoResponse.token_balances;
    }
    {
        let GetPaymentRequest = None::<crate::models::GetPaymentRequest>.unwrap();
        let _: String = GetPaymentRequest.payment_id;
    }
    {
        let GetPaymentResponse = None::<crate::models::GetPaymentResponse>.unwrap();
        let _: crate::models::Payment = GetPaymentResponse.payment;
    }
    {
        let GetTokensMetadataRequest = None::<crate::models::GetTokensMetadataRequest>.unwrap();
        let _: Vec<String> = GetTokensMetadataRequest.token_identifiers;
    }
    {
        let GetTokensMetadataResponse = None::<crate::models::GetTokensMetadataResponse>.unwrap();
        let _: Vec<crate::models::TokenMetadata> = GetTokensMetadataResponse.tokens_metadata;
    }
    match None::<crate::models::InputType>.unwrap() {
        crate::models::InputType::BitcoinAddress(field0) => {
            let _: crate::models::BitcoinAddressDetails = field0;
        }
        crate::models::InputType::Bolt11Invoice(field0) => {
            let _: crate::models::Bolt11InvoiceDetails = field0;
        }
        crate::models::InputType::Bolt12Invoice(field0) => {
            let _: crate::models::Bolt12InvoiceDetails = field0;
        }
        crate::models::InputType::Bolt12Offer(field0) => {
            let _: crate::models::Bolt12OfferDetails = field0;
        }
        crate::models::InputType::LightningAddress(field0) => {
            let _: crate::models::LightningAddressDetails = field0;
        }
        crate::models::InputType::LnurlPay(field0) => {
            let _: crate::models::LnurlPayRequestDetails = field0;
        }
        crate::models::InputType::SilentPaymentAddress(field0) => {
            let _: crate::models::SilentPaymentAddressDetails = field0;
        }
        crate::models::InputType::LnurlAuth(field0) => {
            let _: crate::models::LnurlAuthRequestDetails = field0;
        }
        crate::models::InputType::Url(field0) => {
            let _: String = field0;
        }
        crate::models::InputType::Bip21(field0) => {
            let _: crate::models::Bip21Details = field0;
        }
        crate::models::InputType::Bolt12InvoiceRequest(field0) => {
            let _: crate::models::Bolt12InvoiceRequestDetails = field0;
        }
        crate::models::InputType::LnurlWithdraw(field0) => {
            let _: crate::models::LnurlWithdrawRequestDetails = field0;
        }
        crate::models::InputType::SparkAddress(field0) => {
            let _: crate::models::SparkAddressDetails = field0;
        }
    }
    {
        let LightningAddressDetails = None::<crate::models::LightningAddressDetails>.unwrap();
        let _: String = LightningAddressDetails.address;
        let _: crate::models::LnurlPayRequestDetails = LightningAddressDetails.pay_request;
    }
    {
        let LightningAddressInfo = None::<crate::models::LightningAddressInfo>.unwrap();
        let _: String = LightningAddressInfo.description;
        let _: String = LightningAddressInfo.lightning_address;
        let _: String = LightningAddressInfo.lnurl;
        let _: String = LightningAddressInfo.username;
    }
    {
        let ListFiatCurrenciesResponse = None::<crate::models::ListFiatCurrenciesResponse>.unwrap();
        let _: Vec<crate::models::FiatCurrency> = ListFiatCurrenciesResponse.currencies;
    }
    {
        let ListFiatRatesResponse = None::<crate::models::ListFiatRatesResponse>.unwrap();
        let _: Vec<crate::models::Rate> = ListFiatRatesResponse.rates;
    }
    {
        let ListPaymentsRequest = None::<crate::models::ListPaymentsRequest>.unwrap();
        let _: Option<Vec<crate::models::PaymentType>> = ListPaymentsRequest.type_filter;
        let _: Option<Vec<crate::models::PaymentStatus>> = ListPaymentsRequest.status_filter;
        let _: Option<crate::models::AssetFilter> = ListPaymentsRequest.asset_filter;
        let _: Option<u64> = ListPaymentsRequest.from_timestamp;
        let _: Option<u64> = ListPaymentsRequest.to_timestamp;
        let _: Option<u32> = ListPaymentsRequest.offset;
        let _: Option<u32> = ListPaymentsRequest.limit;
        let _: Option<bool> = ListPaymentsRequest.sort_ascending;
    }
    {
        let ListPaymentsResponse = None::<crate::models::ListPaymentsResponse>.unwrap();
        let _: Vec<crate::models::Payment> = ListPaymentsResponse.payments;
    }
    {
        let ListUnclaimedDepositsRequest =
            None::<crate::models::ListUnclaimedDepositsRequest>.unwrap();
    }
    {
        let ListUnclaimedDepositsResponse =
            None::<crate::models::ListUnclaimedDepositsResponse>.unwrap();
        let _: Vec<crate::models::DepositInfo> = ListUnclaimedDepositsResponse.deposits;
    }
    {
        let LnurlAuthRequestDetails = None::<crate::models::LnurlAuthRequestDetails>.unwrap();
        let _: String = LnurlAuthRequestDetails.k1;
        let _: Option<String> = LnurlAuthRequestDetails.action;
        let _: String = LnurlAuthRequestDetails.domain;
        let _: String = LnurlAuthRequestDetails.url;
    }
    {
        let LnurlPayInfo = None::<crate::models::LnurlPayInfo>.unwrap();
        let _: Option<String> = LnurlPayInfo.ln_address;
        let _: Option<String> = LnurlPayInfo.comment;
        let _: Option<String> = LnurlPayInfo.domain;
        let _: Option<String> = LnurlPayInfo.metadata;
        let _: Option<crate::models::SuccessActionProcessed> =
            LnurlPayInfo.processed_success_action;
        let _: Option<crate::models::SuccessAction> = LnurlPayInfo.raw_success_action;
    }
    {
        let LnurlPayRequest = None::<crate::models::LnurlPayRequest>.unwrap();
        let _: crate::models::PrepareLnurlPayResponse = LnurlPayRequest.prepare_response;
    }
    {
        let LnurlPayRequestDetails = None::<crate::models::LnurlPayRequestDetails>.unwrap();
        let _: String = LnurlPayRequestDetails.callback;
        let _: u64 = LnurlPayRequestDetails.min_sendable;
        let _: u64 = LnurlPayRequestDetails.max_sendable;
        let _: String = LnurlPayRequestDetails.metadata_str;
        let _: u16 = LnurlPayRequestDetails.comment_allowed;
        let _: String = LnurlPayRequestDetails.domain;
        let _: String = LnurlPayRequestDetails.url;
        let _: Option<String> = LnurlPayRequestDetails.address;
        let _: Option<bool> = LnurlPayRequestDetails.allows_nostr;
        let _: Option<String> = LnurlPayRequestDetails.nostr_pubkey;
    }
    {
        let LnurlPayResponse = None::<crate::models::LnurlPayResponse>.unwrap();
        let _: crate::models::Payment = LnurlPayResponse.payment;
        let _: Option<crate::models::SuccessActionProcessed> = LnurlPayResponse.success_action;
    }
    {
        let LnurlWithdrawRequestDetails =
            None::<crate::models::LnurlWithdrawRequestDetails>.unwrap();
        let _: String = LnurlWithdrawRequestDetails.callback;
        let _: String = LnurlWithdrawRequestDetails.k1;
        let _: String = LnurlWithdrawRequestDetails.default_description;
        let _: u64 = LnurlWithdrawRequestDetails.min_withdrawable;
        let _: u64 = LnurlWithdrawRequestDetails.max_withdrawable;
    }
    {
        let LocaleOverrides = None::<crate::models::LocaleOverrides>.unwrap();
        let _: String = LocaleOverrides.locale;
        let _: Option<u32> = LocaleOverrides.spacing;
        let _: crate::models::Symbol = LocaleOverrides.symbol;
    }
    {
        let LocalizedName = None::<crate::models::LocalizedName>.unwrap();
        let _: String = LocalizedName.locale;
        let _: String = LocalizedName.name;
    }
    {
        let LogEntry = None::<crate::logger::LogEntry>.unwrap();
        let _: String = LogEntry.line;
        let _: String = LogEntry.level;
    }
    {
        let MessageSuccessActionData = None::<crate::models::MessageSuccessActionData>.unwrap();
        let _: String = MessageSuccessActionData.message;
    }
    {
        let Payment = None::<crate::models::Payment>.unwrap();
        let _: String = Payment.id;
        let _: crate::models::PaymentType = Payment.payment_type;
        let _: crate::models::PaymentStatus = Payment.status;
        let _: u128 = Payment.amount;
        let _: u128 = Payment.fees;
        let _: u64 = Payment.timestamp;
        let _: crate::models::PaymentMethod = Payment.method;
        let _: Option<crate::models::PaymentDetails> = Payment.details;
    }
    match None::<crate::models::PaymentDetails>.unwrap() {
        crate::models::PaymentDetails::Spark => {}
        crate::models::PaymentDetails::Token { metadata, tx_hash } => {
            let _: crate::models::TokenMetadata = metadata;
            let _: String = tx_hash;
        }
        crate::models::PaymentDetails::Lightning {
            description,
            preimage,
            invoice,
            payment_hash,
            destination_pubkey,
            lnurl_pay_info,
        } => {
            let _: Option<String> = description;
            let _: Option<String> = preimage;
            let _: String = invoice;
            let _: String = payment_hash;
            let _: String = destination_pubkey;
            let _: Option<crate::models::LnurlPayInfo> = lnurl_pay_info;
        }
        crate::models::PaymentDetails::Withdraw { tx_id } => {
            let _: String = tx_id;
        }
        crate::models::PaymentDetails::Deposit { tx_id } => {
            let _: String = tx_id;
        }
    }
    {
        let PaymentRequestSource = None::<crate::models::PaymentRequestSource>.unwrap();
        let _: Option<String> = PaymentRequestSource.bip_21_uri;
        let _: Option<String> = PaymentRequestSource.bip_353_address;
    }
    {
        let PrepareLnurlPayRequest = None::<crate::models::PrepareLnurlPayRequest>.unwrap();
        let _: u64 = PrepareLnurlPayRequest.amount_sats;
        let _: crate::models::LnurlPayRequestDetails = PrepareLnurlPayRequest.pay_request;
        let _: Option<String> = PrepareLnurlPayRequest.comment;
        let _: Option<bool> = PrepareLnurlPayRequest.validate_success_action_url;
    }
    {
        let PrepareLnurlPayResponse = None::<crate::models::PrepareLnurlPayResponse>.unwrap();
        let _: u64 = PrepareLnurlPayResponse.amount_sats;
        let _: Option<String> = PrepareLnurlPayResponse.comment;
        let _: crate::models::LnurlPayRequestDetails = PrepareLnurlPayResponse.pay_request;
        let _: u64 = PrepareLnurlPayResponse.fee_sats;
        let _: crate::models::Bolt11InvoiceDetails = PrepareLnurlPayResponse.invoice_details;
        let _: Option<crate::models::SuccessAction> = PrepareLnurlPayResponse.success_action;
    }
    {
        let PrepareSendPaymentRequest = None::<crate::models::PrepareSendPaymentRequest>.unwrap();
        let _: String = PrepareSendPaymentRequest.payment_request;
        let _: Option<u128> = PrepareSendPaymentRequest.amount;
        let _: Option<String> = PrepareSendPaymentRequest.token_identifier;
    }
    {
        let PrepareSendPaymentResponse = None::<crate::models::PrepareSendPaymentResponse>.unwrap();
        let _: crate::models::SendPaymentMethod = PrepareSendPaymentResponse.payment_method;
        let _: u128 = PrepareSendPaymentResponse.amount;
        let _: Option<String> = PrepareSendPaymentResponse.token_identifier;
    }
    {
        let Rate = None::<crate::models::Rate>.unwrap();
        let _: String = Rate.coin;
        let _: f64 = Rate.value;
    }
    match None::<crate::models::ReceivePaymentMethod>.unwrap() {
        crate::models::ReceivePaymentMethod::SparkAddress => {}
        crate::models::ReceivePaymentMethod::BitcoinAddress => {}
        crate::models::ReceivePaymentMethod::Bolt11Invoice {
            description,
            amount_sats,
        } => {
            let _: String = description;
            let _: Option<u64> = amount_sats;
        }
    }
    {
        let ReceivePaymentRequest = None::<crate::models::ReceivePaymentRequest>.unwrap();
        let _: crate::models::ReceivePaymentMethod = ReceivePaymentRequest.payment_method;
    }
    {
        let ReceivePaymentResponse = None::<crate::models::ReceivePaymentResponse>.unwrap();
        let _: String = ReceivePaymentResponse.payment_request;
        let _: u64 = ReceivePaymentResponse.fee_sats;
    }
    {
        let RefundDepositRequest = None::<crate::models::RefundDepositRequest>.unwrap();
        let _: String = RefundDepositRequest.txid;
        let _: u32 = RefundDepositRequest.vout;
        let _: String = RefundDepositRequest.destination_address;
        let _: crate::models::Fee = RefundDepositRequest.fee;
    }
    {
        let RefundDepositResponse = None::<crate::models::RefundDepositResponse>.unwrap();
        let _: String = RefundDepositResponse.tx_id;
        let _: String = RefundDepositResponse.tx_hex;
    }
    {
        let RegisterLightningAddressRequest =
            None::<crate::models::RegisterLightningAddressRequest>.unwrap();
        let _: String = RegisterLightningAddressRequest.username;
        let _: Option<String> = RegisterLightningAddressRequest.description;
    }
    {
        let SatsPaymentDetails = None::<crate::models::SatsPaymentDetails>.unwrap();
        let _: Option<u64> = SatsPaymentDetails.amount;
    }
    match None::<crate::errors::SdkError>.unwrap() {
        crate::errors::SdkError::SparkError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::InvalidUuid(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::InvalidInput(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::NetworkError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::StorageError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::ChainServiceError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::DepositClaimFeeExceeded {
            tx,
            vout,
            max_fee,
            actual_fee,
        } => {
            let _: String = tx;
            let _: u32 = vout;
            let _: crate::models::Fee = max_fee;
            let _: u64 = actual_fee;
        }
        crate::errors::SdkError::MissingUtxo { tx, vout } => {
            let _: String = tx;
            let _: u32 = vout;
        }
        crate::errors::SdkError::LnurlError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::Generic(field0) => {
            let _: String = field0;
        }
    }
    match None::<crate::events::SdkEvent>.unwrap() {
        crate::events::SdkEvent::Synced => {}
        crate::events::SdkEvent::ClaimDepositsFailed { unclaimed_deposits } => {
            let _: Vec<crate::models::DepositInfo> = unclaimed_deposits;
        }
        crate::events::SdkEvent::ClaimDepositsSucceeded { claimed_deposits } => {
            let _: Vec<crate::models::DepositInfo> = claimed_deposits;
        }
        crate::events::SdkEvent::PaymentSucceeded { payment } => {
            let _: crate::models::Payment = payment;
        }
        crate::events::SdkEvent::PaymentFailed { payment } => {
            let _: crate::models::Payment = payment;
        }
    }
    match None::<crate::models::Seed>.unwrap() {
        crate::models::Seed::Mnemonic {
            mnemonic,
            passphrase,
        } => {
            let _: String = mnemonic;
            let _: Option<String> = passphrase;
        }
        crate::models::Seed::Entropy(field0) => {
            let _: Vec<u8> = field0;
        }
    }
    {
        let SendOnchainFeeQuote = None::<crate::models::SendOnchainFeeQuote>.unwrap();
        let _: String = SendOnchainFeeQuote.id;
        let _: u64 = SendOnchainFeeQuote.expires_at;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_fast;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_medium;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_slow;
    }
    {
        let SendOnchainSpeedFeeQuote = None::<crate::models::SendOnchainSpeedFeeQuote>.unwrap();
        let _: u64 = SendOnchainSpeedFeeQuote.user_fee_sat;
        let _: u64 = SendOnchainSpeedFeeQuote.l1_broadcast_fee_sat;
    }
    match None::<crate::models::SendPaymentMethod>.unwrap() {
        crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => {
            let _: crate::models::BitcoinAddressDetails = address;
            let _: crate::models::SendOnchainFeeQuote = fee_quote;
        }
        crate::models::SendPaymentMethod::Bolt11Invoice {
            invoice_details,
            spark_transfer_fee_sats,
            lightning_fee_sats,
        } => {
            let _: crate::models::Bolt11InvoiceDetails = invoice_details;
            let _: Option<u64> = spark_transfer_fee_sats;
            let _: u64 = lightning_fee_sats;
        }
        crate::models::SendPaymentMethod::SparkAddress {
            address,
            fee,
            token_identifier,
        } => {
            let _: String = address;
            let _: u128 = fee;
            let _: Option<String> = token_identifier;
        }
    }
    match None::<crate::models::SendPaymentOptions>.unwrap() {
        crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => {
            let _: crate::models::OnchainConfirmationSpeed = confirmation_speed;
        }
        crate::models::SendPaymentOptions::Bolt11Invoice {
            prefer_spark,
            completion_timeout_secs,
        } => {
            let _: bool = prefer_spark;
            let _: Option<u32> = completion_timeout_secs;
        }
    }
    {
        let SendPaymentRequest = None::<crate::models::SendPaymentRequest>.unwrap();
        let _: crate::models::PrepareSendPaymentResponse = SendPaymentRequest.prepare_response;
        let _: Option<crate::models::SendPaymentOptions> = SendPaymentRequest.options;
    }
    {
        let SendPaymentResponse = None::<crate::models::SendPaymentResponse>.unwrap();
        let _: crate::models::Payment = SendPaymentResponse.payment;
    }
    {
        let SilentPaymentAddressDetails =
            None::<crate::models::SilentPaymentAddressDetails>.unwrap();
        let _: String = SilentPaymentAddressDetails.address;
        let _: crate::models::BitcoinNetwork = SilentPaymentAddressDetails.network;
        let _: crate::models::PaymentRequestSource = SilentPaymentAddressDetails.source;
    }
    {
        let SparkAddress = None::<crate::models::SparkAddress>.unwrap();
        let _: String = SparkAddress.identity_public_key;
        let _: crate::models::BitcoinNetwork = SparkAddress.network;
        let _: Option<crate::models::SparkInvoiceFields> = SparkAddress.spark_invoice_fields;
        let _: Option<String> = SparkAddress.signature;
    }
    {
        let SparkAddressDetails = None::<crate::models::SparkAddressDetails>.unwrap();
        let _: String = SparkAddressDetails.address;
        let _: crate::models::SparkAddress = SparkAddressDetails.decoded_address;
        let _: crate::models::PaymentRequestSource = SparkAddressDetails.source;
    }
    match None::<crate::models::SparkAddressPaymentType>.unwrap() {
        crate::models::SparkAddressPaymentType::TokensPayment(field0) => {
            let _: crate::models::TokensPaymentDetails = field0;
        }
        crate::models::SparkAddressPaymentType::SatsPayment(field0) => {
            let _: crate::models::SatsPaymentDetails = field0;
        }
    }
    {
        let SparkInvoiceFields = None::<crate::models::SparkInvoiceFields>.unwrap();
        let _: String = SparkInvoiceFields.id;
        let _: u32 = SparkInvoiceFields.version;
        let _: Option<String> = SparkInvoiceFields.memo;
        let _: Option<String> = SparkInvoiceFields.sender_public_key;
        let _: Option<u64> = SparkInvoiceFields.expiry_time;
        let _: Option<crate::models::SparkAddressPaymentType> = SparkInvoiceFields.payment_type;
    }
    match None::<crate::models::SuccessAction>.unwrap() {
        crate::models::SuccessAction::Aes { data } => {
            let _: crate::models::AesSuccessActionData = data;
        }
        crate::models::SuccessAction::Message { data } => {
            let _: crate::models::MessageSuccessActionData = data;
        }
        crate::models::SuccessAction::Url { data } => {
            let _: crate::models::UrlSuccessActionData = data;
        }
    }
    match None::<crate::models::SuccessActionProcessed>.unwrap() {
        crate::models::SuccessActionProcessed::Aes { result } => {
            let _: crate::models::AesSuccessActionDataResult = result;
        }
        crate::models::SuccessActionProcessed::Message { data } => {
            let _: crate::models::MessageSuccessActionData = data;
        }
        crate::models::SuccessActionProcessed::Url { data } => {
            let _: crate::models::UrlSuccessActionData = data;
        }
    }
    {
        let Symbol = None::<crate::models::Symbol>.unwrap();
        let _: Option<String> = Symbol.grapheme;
        let _: Option<String> = Symbol.template;
        let _: Option<bool> = Symbol.rtl;
        let _: Option<u32> = Symbol.position;
    }
    {
        let SyncWalletRequest = None::<crate::models::SyncWalletRequest>.unwrap();
    }
    {
        let SyncWalletResponse = None::<crate::models::SyncWalletResponse>.unwrap();
    }
    {
        let TokenBalance = None::<crate::models::TokenBalance>.unwrap();
        let _: u128 = TokenBalance.balance;
        let _: crate::models::TokenMetadata = TokenBalance.token_metadata;
    }
    {
        let TokenMetadata = None::<crate::models::TokenMetadata>.unwrap();
        let _: String = TokenMetadata.identifier;
        let _: String = TokenMetadata.issuer_public_key;
        let _: String = TokenMetadata.name;
        let _: String = TokenMetadata.ticker;
        let _: u32 = TokenMetadata.decimals;
        let _: u128 = TokenMetadata.max_supply;
        let _: bool = TokenMetadata.is_freezable;
    }
    {
        let TokensPaymentDetails = None::<crate::models::TokensPaymentDetails>.unwrap();
        let _: Option<String> = TokensPaymentDetails.token_identifier;
        let _: Option<u128> = TokensPaymentDetails.amount;
    }
    {
        let UrlSuccessActionData = None::<crate::models::UrlSuccessActionData>.unwrap();
        let _: String = UrlSuccessActionData.description;
        let _: String = UrlSuccessActionData.url;
        let _: bool = UrlSuccessActionData.matches_callback_domain;
    }
    match None::<crate::models::WaitForPaymentIdentifier>.unwrap() {
        crate::models::WaitForPaymentIdentifier::PaymentId(field0) => {
            let _: String = field0;
        }
        crate::models::WaitForPaymentIdentifier::PaymentRequest(field0) => {
            let _: String = field0;
        }
    }
    {
        let WaitForPaymentRequest = None::<crate::models::WaitForPaymentRequest>.unwrap();
        let _: crate::models::WaitForPaymentIdentifier = WaitForPaymentRequest.identifier;
    }
    {
        let WaitForPaymentResponse = None::<crate::models::WaitForPaymentResponse>.unwrap();
        let _: crate::models::Payment = WaitForPaymentResponse.payment;
    }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<dyn Storage>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for Arc<dyn Storage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<dyn Storage>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BreezSdk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, crate::models::TokenBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::models::TokenBalance)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<dyn Storage>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::events::SdkEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for crate::models::AesSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_ciphertext = <String>::sse_decode(deserializer);
        let mut var_iv = <String>::sse_decode(deserializer);
        return crate::models::AesSuccessActionData {
            description: var_description,
            ciphertext: var_ciphertext,
            iv: var_iv,
        };
    }
}

impl SseDecode for crate::models::AesSuccessActionDataDecrypted {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_plaintext = <String>::sse_decode(deserializer);
        return crate::models::AesSuccessActionDataDecrypted {
            description: var_description,
            plaintext: var_plaintext,
        };
    }
}

impl SseDecode for crate::models::AesSuccessActionDataResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data =
                    <crate::models::AesSuccessActionDataDecrypted>::sse_decode(deserializer);
                return crate::models::AesSuccessActionDataResult::Decrypted { data: var_data };
            }
            1 => {
                let mut var_reason = <String>::sse_decode(deserializer);
                return crate::models::AesSuccessActionDataResult::ErrorStatus {
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Amount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::models::Amount::Bitcoin {
                    amount_msat: var_amountMsat,
                };
            }
            1 => {
                let mut var_iso4217Code = <String>::sse_decode(deserializer);
                let mut var_fractionalAmount = <u64>::sse_decode(deserializer);
                return crate::models::Amount::Currency {
                    iso4217_code: var_iso4217Code,
                    fractional_amount: var_fractionalAmount,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::AssetFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::AssetFilter::Bitcoin;
            }
            1 => {
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                return crate::models::AssetFilter::Token {
                    token_identifier: var_tokenIdentifier,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Bip21Details {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSat = <Option<u64>>::sse_decode(deserializer);
        let mut var_assetId = <Option<String>>::sse_decode(deserializer);
        let mut var_uri = <String>::sse_decode(deserializer);
        let mut var_extras = <Vec<crate::models::Bip21Extra>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_message = <Option<String>>::sse_decode(deserializer);
        let mut var_paymentMethods = <Vec<crate::models::InputType>>::sse_decode(deserializer);
        return crate::models::Bip21Details {
            amount_sat: var_amountSat,
            asset_id: var_assetId,
            uri: var_uri,
            extras: var_extras,
            label: var_label,
            message: var_message,
            payment_methods: var_paymentMethods,
        };
    }
}

impl SseDecode for crate::models::Bip21Extra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_key = <String>::sse_decode(deserializer);
        let mut var_value = <String>::sse_decode(deserializer);
        return crate::models::Bip21Extra {
            key: var_key,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::BitcoinAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::BitcoinAddressDetails {
            address: var_address,
            network: var_network,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::BitcoinNetwork {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::BitcoinNetwork::Bitcoin,
            1 => crate::models::BitcoinNetwork::Testnet3,
            2 => crate::models::BitcoinNetwork::Testnet4,
            3 => crate::models::BitcoinNetwork::Signet,
            4 => crate::models::BitcoinNetwork::Regtest,
            _ => unreachable!("Invalid variant for BitcoinNetwork: {}", inner),
        };
    }
}

impl SseDecode for crate::models::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bolt11 = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt11Invoice {
            bolt11: var_bolt11,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt11InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_descriptionHash = <Option<String>>::sse_decode(deserializer);
        let mut var_expiry = <u64>::sse_decode(deserializer);
        let mut var_invoice = <crate::models::Bolt11Invoice>::sse_decode(deserializer);
        let mut var_minFinalCltvExpiryDelta = <u64>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_payeePubkey = <String>::sse_decode(deserializer);
        let mut var_paymentHash = <String>::sse_decode(deserializer);
        let mut var_paymentSecret = <String>::sse_decode(deserializer);
        let mut var_routingHints = <Vec<crate::models::Bolt11RouteHint>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::models::Bolt11InvoiceDetails {
            amount_msat: var_amountMsat,
            description: var_description,
            description_hash: var_descriptionHash,
            expiry: var_expiry,
            invoice: var_invoice,
            min_final_cltv_expiry_delta: var_minFinalCltvExpiryDelta,
            network: var_network,
            payee_pubkey: var_payeePubkey,
            payment_hash: var_paymentHash,
            payment_secret: var_paymentSecret,
            routing_hints: var_routingHints,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::models::Bolt11RouteHint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hops = <Vec<crate::models::Bolt11RouteHintHop>>::sse_decode(deserializer);
        return crate::models::Bolt11RouteHint { hops: var_hops };
    }
}

impl SseDecode for crate::models::Bolt11RouteHintHop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_srcNodeId = <String>::sse_decode(deserializer);
        let mut var_shortChannelId = <String>::sse_decode(deserializer);
        let mut var_feesBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_feesProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        return crate::models::Bolt11RouteHintHop {
            src_node_id: var_srcNodeId,
            short_channel_id: var_shortChannelId,
            fees_base_msat: var_feesBaseMsat,
            fees_proportional_millionths: var_feesProportionalMillionths,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
        };
    }
}

impl SseDecode for crate::models::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt12Invoice {
            invoice: var_invoice,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt12InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountMsat = <u64>::sse_decode(deserializer);
        let mut var_invoice = <crate::models::Bolt12Invoice>::sse_decode(deserializer);
        return crate::models::Bolt12InvoiceDetails {
            amount_msat: var_amountMsat,
            invoice: var_invoice,
        };
    }
}

impl SseDecode for crate::models::Bolt12InvoiceRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::Bolt12InvoiceRequestDetails {};
    }
}

impl SseDecode for crate::models::Bolt12Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_offer = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt12Offer {
            offer: var_offer,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt12OfferBlindedPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blindedHops = <Vec<String>>::sse_decode(deserializer);
        return crate::models::Bolt12OfferBlindedPath {
            blinded_hops: var_blindedHops,
        };
    }
}

impl SseDecode for crate::models::Bolt12OfferDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_absoluteExpiry = <Option<u64>>::sse_decode(deserializer);
        let mut var_chains = <Vec<String>>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_issuer = <Option<String>>::sse_decode(deserializer);
        let mut var_minAmount = <Option<crate::models::Amount>>::sse_decode(deserializer);
        let mut var_offer = <crate::models::Bolt12Offer>::sse_decode(deserializer);
        let mut var_paths = <Vec<crate::models::Bolt12OfferBlindedPath>>::sse_decode(deserializer);
        let mut var_signingPubkey = <Option<String>>::sse_decode(deserializer);
        return crate::models::Bolt12OfferDetails {
            absolute_expiry: var_absoluteExpiry,
            chains: var_chains,
            description: var_description,
            issuer: var_issuer,
            min_amount: var_minAmount,
            offer: var_offer,
            paths: var_paths,
            signing_pubkey: var_signingPubkey,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::CheckLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        return crate::models::CheckLightningAddressRequest {
            username: var_username,
        };
    }
}

impl SseDecode for crate::models::ClaimDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_maxFee = <Option<crate::models::Fee>>::sse_decode(deserializer);
        return crate::models::ClaimDepositRequest {
            txid: var_txid,
            vout: var_vout,
            max_fee: var_maxFee,
        };
    }
}

impl SseDecode for crate::models::ClaimDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::ClaimDepositResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_apiKey = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::models::Network>::sse_decode(deserializer);
        let mut var_syncIntervalSecs = <u32>::sse_decode(deserializer);
        let mut var_maxDepositClaimFee = <Option<crate::models::Fee>>::sse_decode(deserializer);
        let mut var_lnurlDomain = <Option<String>>::sse_decode(deserializer);
        let mut var_preferSparkOverLightning = <bool>::sse_decode(deserializer);
        return crate::models::Config {
            api_key: var_apiKey,
            network: var_network,
            sync_interval_secs: var_syncIntervalSecs,
            max_deposit_claim_fee: var_maxDepositClaimFee,
            lnurl_domain: var_lnurlDomain,
            prefer_spark_over_lightning: var_preferSparkOverLightning,
        };
    }
}

impl SseDecode for crate::models::ConnectRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_config = <crate::models::Config>::sse_decode(deserializer);
        let mut var_seed = <crate::models::Seed>::sse_decode(deserializer);
        let mut var_storageDir = <String>::sse_decode(deserializer);
        return crate::models::ConnectRequest {
            config: var_config,
            seed: var_seed,
            storage_dir: var_storageDir,
        };
    }
}

impl SseDecode for crate::models::Credentials {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        return crate::models::Credentials {
            username: var_username,
            password: var_password,
        };
    }
}

impl SseDecode for crate::models::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_fractionSize = <u32>::sse_decode(deserializer);
        let mut var_spacing = <Option<u32>>::sse_decode(deserializer);
        let mut var_symbol = <Option<crate::models::Symbol>>::sse_decode(deserializer);
        let mut var_uniqSymbol = <Option<crate::models::Symbol>>::sse_decode(deserializer);
        let mut var_localizedName = <Vec<crate::models::LocalizedName>>::sse_decode(deserializer);
        let mut var_localeOverrides =
            <Vec<crate::models::LocaleOverrides>>::sse_decode(deserializer);
        return crate::models::CurrencyInfo {
            name: var_name,
            fraction_size: var_fractionSize,
            spacing: var_spacing,
            symbol: var_symbol,
            uniq_symbol: var_uniqSymbol,
            localized_name: var_localizedName,
            locale_overrides: var_localeOverrides,
        };
    }
}

impl SseDecode for crate::errors::DepositClaimError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                let mut var_maxFee = <crate::models::Fee>::sse_decode(deserializer);
                let mut var_actualFee = <u64>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::DepositClaimFeeExceeded {
                    tx: var_tx,
                    vout: var_vout,
                    max_fee: var_maxFee,
                    actual_fee: var_actualFee,
                };
            }
            1 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::MissingUtxo {
                    tx: var_tx,
                    vout: var_vout,
                };
            }
            2 => {
                let mut var_message = <String>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::Generic {
                    message: var_message,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::DepositInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_refundTx = <Option<String>>::sse_decode(deserializer);
        let mut var_refundTxId = <Option<String>>::sse_decode(deserializer);
        let mut var_claimError =
            <Option<crate::errors::DepositClaimError>>::sse_decode(deserializer);
        return crate::models::DepositInfo {
            txid: var_txid,
            vout: var_vout,
            amount_sats: var_amountSats,
            refund_tx: var_refundTx,
            refund_tx_id: var_refundTxId,
            claim_error: var_claimError,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_amount = <u64>::sse_decode(deserializer);
                return crate::models::Fee::Fixed { amount: var_amount };
            }
            1 => {
                let mut var_satPerVbyte = <u64>::sse_decode(deserializer);
                return crate::models::Fee::Rate {
                    sat_per_vbyte: var_satPerVbyte,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_info = <crate::models::CurrencyInfo>::sse_decode(deserializer);
        return crate::models::FiatCurrency {
            id: var_id,
            info: var_info,
        };
    }
}

impl SseDecode for crate::models::GetInfoRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ensureSynced = <Option<bool>>::sse_decode(deserializer);
        return crate::models::GetInfoRequest {
            ensure_synced: var_ensureSynced,
        };
    }
}

impl SseDecode for crate::models::GetInfoResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_balanceSats = <u64>::sse_decode(deserializer);
        let mut var_tokenBalances =
            <std::collections::HashMap<String, crate::models::TokenBalance>>::sse_decode(
                deserializer,
            );
        return crate::models::GetInfoResponse {
            balance_sats: var_balanceSats,
            token_balances: var_tokenBalances,
        };
    }
}

impl SseDecode for crate::models::GetPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentId = <String>::sse_decode(deserializer);
        return crate::models::GetPaymentRequest {
            payment_id: var_paymentId,
        };
    }
}

impl SseDecode for crate::models::GetPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::GetPaymentResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::GetTokensMetadataRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokenIdentifiers = <Vec<String>>::sse_decode(deserializer);
        return crate::models::GetTokensMetadataRequest {
            token_identifiers: var_tokenIdentifiers,
        };
    }
}

impl SseDecode for crate::models::GetTokensMetadataResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokensMetadata = <Vec<crate::models::TokenMetadata>>::sse_decode(deserializer);
        return crate::models::GetTokensMetadataResponse {
            tokens_metadata: var_tokensMetadata,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::InputType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::models::BitcoinAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::BitcoinAddress(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt11Invoice(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <crate::models::Bolt12InvoiceDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12Invoice(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::models::Bolt12OfferDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12Offer(var_field0);
            }
            4 => {
                let mut var_field0 =
                    <crate::models::LightningAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::LightningAddress(var_field0);
            }
            5 => {
                let mut var_field0 =
                    <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlPay(var_field0);
            }
            6 => {
                let mut var_field0 =
                    <crate::models::SilentPaymentAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::SilentPaymentAddress(var_field0);
            }
            7 => {
                let mut var_field0 =
                    <crate::models::LnurlAuthRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlAuth(var_field0);
            }
            8 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::models::InputType::Url(var_field0);
            }
            9 => {
                let mut var_field0 = <crate::models::Bip21Details>::sse_decode(deserializer);
                return crate::models::InputType::Bip21(var_field0);
            }
            10 => {
                let mut var_field0 =
                    <crate::models::Bolt12InvoiceRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12InvoiceRequest(var_field0);
            }
            11 => {
                let mut var_field0 =
                    <crate::models::LnurlWithdrawRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlWithdraw(var_field0);
            }
            12 => {
                let mut var_field0 = <crate::models::SparkAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::SparkAddress(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::KeySetType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::KeySetType::Default,
            1 => crate::models::KeySetType::Taproot,
            2 => crate::models::KeySetType::NativeSegwit,
            3 => crate::models::KeySetType::WrappedSegwit,
            4 => crate::models::KeySetType::Legacy,
            _ => unreachable!("Invalid variant for KeySetType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::LightningAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        return crate::models::LightningAddressDetails {
            address: var_address,
            pay_request: var_payRequest,
        };
    }
}

impl SseDecode for crate::models::LightningAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_lightningAddress = <String>::sse_decode(deserializer);
        let mut var_lnurl = <String>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        return crate::models::LightningAddressInfo {
            description: var_description,
            lightning_address: var_lightningAddress,
            lnurl: var_lnurl,
            username: var_username,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bip21Extra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bip21Extra>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt11RouteHint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt11RouteHint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt11RouteHintHop> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt11RouteHintHop>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt12OfferBlindedPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt12OfferBlindedPath>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::DepositInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::DepositInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListFiatCurrenciesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currencies = <Vec<crate::models::FiatCurrency>>::sse_decode(deserializer);
        return crate::models::ListFiatCurrenciesResponse {
            currencies: var_currencies,
        };
    }
}

impl SseDecode for Vec<crate::models::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::FiatCurrency>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListFiatRatesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rates = <Vec<crate::models::Rate>>::sse_decode(deserializer);
        return crate::models::ListFiatRatesResponse { rates: var_rates };
    }
}

impl SseDecode for Vec<crate::models::InputType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::InputType>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::LocaleOverrides> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::LocaleOverrides>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::LocalizedName> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::LocalizedName>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Payment>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::PaymentStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::PaymentStatus>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::PaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::PaymentType>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListPaymentsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_typeFilter =
            <Option<Vec<crate::models::PaymentType>>>::sse_decode(deserializer);
        let mut var_statusFilter =
            <Option<Vec<crate::models::PaymentStatus>>>::sse_decode(deserializer);
        let mut var_assetFilter = <Option<crate::models::AssetFilter>>::sse_decode(deserializer);
        let mut var_fromTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_toTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_offset = <Option<u32>>::sse_decode(deserializer);
        let mut var_limit = <Option<u32>>::sse_decode(deserializer);
        let mut var_sortAscending = <Option<bool>>::sse_decode(deserializer);
        return crate::models::ListPaymentsRequest {
            type_filter: var_typeFilter,
            status_filter: var_statusFilter,
            asset_filter: var_assetFilter,
            from_timestamp: var_fromTimestamp,
            to_timestamp: var_toTimestamp,
            offset: var_offset,
            limit: var_limit,
            sort_ascending: var_sortAscending,
        };
    }
}

impl SseDecode for crate::models::ListPaymentsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payments = <Vec<crate::models::Payment>>::sse_decode(deserializer);
        return crate::models::ListPaymentsResponse {
            payments: var_payments,
        };
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Rate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Rate>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::models::TokenBalance)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::models::TokenBalance)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::TokenMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::TokenMetadata>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListUnclaimedDepositsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::ListUnclaimedDepositsRequest {};
    }
}

impl SseDecode for crate::models::ListUnclaimedDepositsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deposits = <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
        return crate::models::ListUnclaimedDepositsResponse {
            deposits: var_deposits,
        };
    }
}

impl SseDecode for crate::models::LnurlAuthRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_k1 = <String>::sse_decode(deserializer);
        let mut var_action = <Option<String>>::sse_decode(deserializer);
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        return crate::models::LnurlAuthRequestDetails {
            k1: var_k1,
            action: var_action,
            domain: var_domain,
            url: var_url,
        };
    }
}

impl SseDecode for crate::models::LnurlPayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lnAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_domain = <Option<String>>::sse_decode(deserializer);
        let mut var_metadata = <Option<String>>::sse_decode(deserializer);
        let mut var_processedSuccessAction =
            <Option<crate::models::SuccessActionProcessed>>::sse_decode(deserializer);
        let mut var_rawSuccessAction =
            <Option<crate::models::SuccessAction>>::sse_decode(deserializer);
        return crate::models::LnurlPayInfo {
            ln_address: var_lnAddress,
            comment: var_comment,
            domain: var_domain,
            metadata: var_metadata,
            processed_success_action: var_processedSuccessAction,
            raw_success_action: var_rawSuccessAction,
        };
    }
}

impl SseDecode for crate::models::LnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prepareResponse =
            <crate::models::PrepareLnurlPayResponse>::sse_decode(deserializer);
        return crate::models::LnurlPayRequest {
            prepare_response: var_prepareResponse,
        };
    }
}

impl SseDecode for crate::models::LnurlPayRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_callback = <String>::sse_decode(deserializer);
        let mut var_minSendable = <u64>::sse_decode(deserializer);
        let mut var_maxSendable = <u64>::sse_decode(deserializer);
        let mut var_metadataStr = <String>::sse_decode(deserializer);
        let mut var_commentAllowed = <u16>::sse_decode(deserializer);
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_address = <Option<String>>::sse_decode(deserializer);
        let mut var_allowsNostr = <Option<bool>>::sse_decode(deserializer);
        let mut var_nostrPubkey = <Option<String>>::sse_decode(deserializer);
        return crate::models::LnurlPayRequestDetails {
            callback: var_callback,
            min_sendable: var_minSendable,
            max_sendable: var_maxSendable,
            metadata_str: var_metadataStr,
            comment_allowed: var_commentAllowed,
            domain: var_domain,
            url: var_url,
            address: var_address,
            allows_nostr: var_allowsNostr,
            nostr_pubkey: var_nostrPubkey,
        };
    }
}

impl SseDecode for crate::models::LnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        let mut var_successAction =
            <Option<crate::models::SuccessActionProcessed>>::sse_decode(deserializer);
        return crate::models::LnurlPayResponse {
            payment: var_payment,
            success_action: var_successAction,
        };
    }
}

impl SseDecode for crate::models::LnurlWithdrawRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_callback = <String>::sse_decode(deserializer);
        let mut var_k1 = <String>::sse_decode(deserializer);
        let mut var_defaultDescription = <String>::sse_decode(deserializer);
        let mut var_minWithdrawable = <u64>::sse_decode(deserializer);
        let mut var_maxWithdrawable = <u64>::sse_decode(deserializer);
        return crate::models::LnurlWithdrawRequestDetails {
            callback: var_callback,
            k1: var_k1,
            default_description: var_defaultDescription,
            min_withdrawable: var_minWithdrawable,
            max_withdrawable: var_maxWithdrawable,
        };
    }
}

impl SseDecode for crate::models::LocaleOverrides {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_spacing = <Option<u32>>::sse_decode(deserializer);
        let mut var_symbol = <crate::models::Symbol>::sse_decode(deserializer);
        return crate::models::LocaleOverrides {
            locale: var_locale,
            spacing: var_spacing,
            symbol: var_symbol,
        };
    }
}

impl SseDecode for crate::models::LocalizedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::models::LocalizedName {
            locale: var_locale,
            name: var_name,
        };
    }
}

impl SseDecode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_line = <String>::sse_decode(deserializer);
        let mut var_level = <String>::sse_decode(deserializer);
        return crate::logger::LogEntry {
            line: var_line,
            level: var_level,
        };
    }
}

impl SseDecode for crate::models::MessageSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::models::MessageSuccessActionData {
            message: var_message,
        };
    }
}

impl SseDecode for crate::models::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::Network::Mainnet,
            1 => crate::models::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::models::OnchainConfirmationSpeed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::OnchainConfirmationSpeed::Fast,
            1 => crate::models::OnchainConfirmationSpeed::Medium,
            2 => crate::models::OnchainConfirmationSpeed::Slow,
            _ => unreachable!("Invalid variant for OnchainConfirmationSpeed: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Amount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Amount>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::AssetFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::AssetFilter>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Credentials> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Credentials>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::errors::DepositClaimError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::errors::DepositClaimError>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Fee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Fee>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LightningAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LightningAddressInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LnurlPayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LnurlPayInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::PaymentDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SendPaymentOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SendPaymentOptions>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SparkAddressPaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SparkAddressPaymentType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SparkInvoiceFields> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SparkInvoiceFields>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SuccessAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SuccessAction>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SuccessActionProcessed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SuccessActionProcessed>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Symbol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Symbol>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::PaymentStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::PaymentStatus>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::PaymentType>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::PaymentType>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_paymentType = <crate::models::PaymentType>::sse_decode(deserializer);
        let mut var_status = <crate::models::PaymentStatus>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_fees = <u128>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_method = <crate::models::PaymentMethod>::sse_decode(deserializer);
        let mut var_details = <Option<crate::models::PaymentDetails>>::sse_decode(deserializer);
        return crate::models::Payment {
            id: var_id,
            payment_type: var_paymentType,
            status: var_status,
            amount: var_amount,
            fees: var_fees,
            timestamp: var_timestamp,
            method: var_method,
            details: var_details,
        };
    }
}

impl SseDecode for crate::models::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::PaymentDetails::Spark;
            }
            1 => {
                let mut var_metadata = <crate::models::TokenMetadata>::sse_decode(deserializer);
                let mut var_txHash = <String>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Token {
                    metadata: var_metadata,
                    tx_hash: var_txHash,
                };
            }
            2 => {
                let mut var_description = <Option<String>>::sse_decode(deserializer);
                let mut var_preimage = <Option<String>>::sse_decode(deserializer);
                let mut var_invoice = <String>::sse_decode(deserializer);
                let mut var_paymentHash = <String>::sse_decode(deserializer);
                let mut var_destinationPubkey = <String>::sse_decode(deserializer);
                let mut var_lnurlPayInfo =
                    <Option<crate::models::LnurlPayInfo>>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Lightning {
                    description: var_description,
                    preimage: var_preimage,
                    invoice: var_invoice,
                    payment_hash: var_paymentHash,
                    destination_pubkey: var_destinationPubkey,
                    lnurl_pay_info: var_lnurlPayInfo,
                };
            }
            3 => {
                let mut var_txId = <String>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Withdraw { tx_id: var_txId };
            }
            4 => {
                let mut var_txId = <String>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Deposit { tx_id: var_txId };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentMethod::Lightning,
            1 => crate::models::PaymentMethod::Spark,
            2 => crate::models::PaymentMethod::Token,
            3 => crate::models::PaymentMethod::Deposit,
            4 => crate::models::PaymentMethod::Withdraw,
            5 => crate::models::PaymentMethod::Unknown,
            _ => unreachable!("Invalid variant for PaymentMethod: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PaymentRequestSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bip21Uri = <Option<String>>::sse_decode(deserializer);
        let mut var_bip353Address = <Option<String>>::sse_decode(deserializer);
        return crate::models::PaymentRequestSource {
            bip_21_uri: var_bip21Uri,
            bip_353_address: var_bip353Address,
        };
    }
}

impl SseDecode for crate::models::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentStatus::Completed,
            1 => crate::models::PaymentStatus::Pending,
            2 => crate::models::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentType::Send,
            1 => crate::models::PaymentType::Receive,
            _ => unreachable!("Invalid variant for PaymentType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PrepareLnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_validateSuccessActionUrl = <Option<bool>>::sse_decode(deserializer);
        return crate::models::PrepareLnurlPayRequest {
            amount_sats: var_amountSats,
            pay_request: var_payRequest,
            comment: var_comment,
            validate_success_action_url: var_validateSuccessActionUrl,
        };
    }
}

impl SseDecode for crate::models::PrepareLnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        let mut var_feeSats = <u64>::sse_decode(deserializer);
        let mut var_invoiceDetails =
            <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
        let mut var_successAction =
            <Option<crate::models::SuccessAction>>::sse_decode(deserializer);
        return crate::models::PrepareLnurlPayResponse {
            amount_sats: var_amountSats,
            comment: var_comment,
            pay_request: var_payRequest,
            fee_sats: var_feeSats,
            invoice_details: var_invoiceDetails,
            success_action: var_successAction,
        };
    }
}

impl SseDecode for crate::models::PrepareSendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentRequest = <String>::sse_decode(deserializer);
        let mut var_amount = <Option<u128>>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        return crate::models::PrepareSendPaymentRequest {
            payment_request: var_paymentRequest,
            amount: var_amount,
            token_identifier: var_tokenIdentifier,
        };
    }
}

impl SseDecode for crate::models::PrepareSendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentMethod = <crate::models::SendPaymentMethod>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        return crate::models::PrepareSendPaymentResponse {
            payment_method: var_paymentMethod,
            amount: var_amount,
            token_identifier: var_tokenIdentifier,
        };
    }
}

impl SseDecode for crate::models::Rate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_coin = <String>::sse_decode(deserializer);
        let mut var_value = <f64>::sse_decode(deserializer);
        return crate::models::Rate {
            coin: var_coin,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::ReceivePaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::ReceivePaymentMethod::SparkAddress;
            }
            1 => {
                return crate::models::ReceivePaymentMethod::BitcoinAddress;
            }
            2 => {
                let mut var_description = <String>::sse_decode(deserializer);
                let mut var_amountSats = <Option<u64>>::sse_decode(deserializer);
                return crate::models::ReceivePaymentMethod::Bolt11Invoice {
                    description: var_description,
                    amount_sats: var_amountSats,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::ReceivePaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentMethod = <crate::models::ReceivePaymentMethod>::sse_decode(deserializer);
        return crate::models::ReceivePaymentRequest {
            payment_method: var_paymentMethod,
        };
    }
}

impl SseDecode for crate::models::ReceivePaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentRequest = <String>::sse_decode(deserializer);
        let mut var_feeSats = <u64>::sse_decode(deserializer);
        return crate::models::ReceivePaymentResponse {
            payment_request: var_paymentRequest,
            fee_sats: var_feeSats,
        };
    }
}

impl SseDecode for (String, crate::models::TokenBalance) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::models::TokenBalance>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::models::RefundDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_destinationAddress = <String>::sse_decode(deserializer);
        let mut var_fee = <crate::models::Fee>::sse_decode(deserializer);
        return crate::models::RefundDepositRequest {
            txid: var_txid,
            vout: var_vout,
            destination_address: var_destinationAddress,
            fee: var_fee,
        };
    }
}

impl SseDecode for crate::models::RefundDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txId = <String>::sse_decode(deserializer);
        let mut var_txHex = <String>::sse_decode(deserializer);
        return crate::models::RefundDepositResponse {
            tx_id: var_txId,
            tx_hex: var_txHex,
        };
    }
}

impl SseDecode for crate::models::RegisterLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        return crate::models::RegisterLightningAddressRequest {
            username: var_username,
            description: var_description,
        };
    }
}

impl SseDecode for crate::models::SatsPaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amount = <Option<u64>>::sse_decode(deserializer);
        return crate::models::SatsPaymentDetails { amount: var_amount };
    }
}

impl SseDecode for crate::errors::SdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::SparkError(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::InvalidUuid(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::InvalidInput(var_field0);
            }
            3 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::NetworkError(var_field0);
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::StorageError(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::ChainServiceError(var_field0);
            }
            6 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                let mut var_maxFee = <crate::models::Fee>::sse_decode(deserializer);
                let mut var_actualFee = <u64>::sse_decode(deserializer);
                return crate::errors::SdkError::DepositClaimFeeExceeded {
                    tx: var_tx,
                    vout: var_vout,
                    max_fee: var_maxFee,
                    actual_fee: var_actualFee,
                };
            }
            7 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                return crate::errors::SdkError::MissingUtxo {
                    tx: var_tx,
                    vout: var_vout,
                };
            }
            8 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::LnurlError(var_field0);
            }
            9 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::Generic(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::events::SdkEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::events::SdkEvent::Synced;
            }
            1 => {
                let mut var_unclaimedDeposits =
                    <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
                return crate::events::SdkEvent::ClaimDepositsFailed {
                    unclaimed_deposits: var_unclaimedDeposits,
                };
            }
            2 => {
                let mut var_claimedDeposits =
                    <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
                return crate::events::SdkEvent::ClaimDepositsSucceeded {
                    claimed_deposits: var_claimedDeposits,
                };
            }
            3 => {
                let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
                return crate::events::SdkEvent::PaymentSucceeded {
                    payment: var_payment,
                };
            }
            4 => {
                let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
                return crate::events::SdkEvent::PaymentFailed {
                    payment: var_payment,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Seed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_mnemonic = <String>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::models::Seed::Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            1 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::models::Seed::Entropy(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendOnchainFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_expiresAt = <u64>::sse_decode(deserializer);
        let mut var_speedFast = <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        let mut var_speedMedium =
            <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        let mut var_speedSlow = <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        return crate::models::SendOnchainFeeQuote {
            id: var_id,
            expires_at: var_expiresAt,
            speed_fast: var_speedFast,
            speed_medium: var_speedMedium,
            speed_slow: var_speedSlow,
        };
    }
}

impl SseDecode for crate::models::SendOnchainSpeedFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_userFeeSat = <u64>::sse_decode(deserializer);
        let mut var_l1BroadcastFeeSat = <u64>::sse_decode(deserializer);
        return crate::models::SendOnchainSpeedFeeQuote {
            user_fee_sat: var_userFeeSat,
            l1_broadcast_fee_sat: var_l1BroadcastFeeSat,
        };
    }
}

impl SseDecode for crate::models::SendPaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_address =
                    <crate::models::BitcoinAddressDetails>::sse_decode(deserializer);
                let mut var_feeQuote =
                    <crate::models::SendOnchainFeeQuote>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::BitcoinAddress {
                    address: var_address,
                    fee_quote: var_feeQuote,
                };
            }
            1 => {
                let mut var_invoiceDetails =
                    <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
                let mut var_sparkTransferFeeSats = <Option<u64>>::sse_decode(deserializer);
                let mut var_lightningFeeSats = <u64>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::Bolt11Invoice {
                    invoice_details: var_invoiceDetails,
                    spark_transfer_fee_sats: var_sparkTransferFeeSats,
                    lightning_fee_sats: var_lightningFeeSats,
                };
            }
            2 => {
                let mut var_address = <String>::sse_decode(deserializer);
                let mut var_fee = <u128>::sse_decode(deserializer);
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::SparkAddress {
                    address: var_address,
                    fee: var_fee,
                    token_identifier: var_tokenIdentifier,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendPaymentOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_confirmationSpeed =
                    <crate::models::OnchainConfirmationSpeed>::sse_decode(deserializer);
                return crate::models::SendPaymentOptions::BitcoinAddress {
                    confirmation_speed: var_confirmationSpeed,
                };
            }
            1 => {
                let mut var_preferSpark = <bool>::sse_decode(deserializer);
                let mut var_completionTimeoutSecs = <Option<u32>>::sse_decode(deserializer);
                return crate::models::SendPaymentOptions::Bolt11Invoice {
                    prefer_spark: var_preferSpark,
                    completion_timeout_secs: var_completionTimeoutSecs,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prepareResponse =
            <crate::models::PrepareSendPaymentResponse>::sse_decode(deserializer);
        let mut var_options = <Option<crate::models::SendPaymentOptions>>::sse_decode(deserializer);
        return crate::models::SendPaymentRequest {
            prepare_response: var_prepareResponse,
            options: var_options,
        };
    }
}

impl SseDecode for crate::models::SendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::SendPaymentResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::SilentPaymentAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::SilentPaymentAddressDetails {
            address: var_address,
            network: var_network,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::SparkAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_identityPublicKey = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_sparkInvoiceFields =
            <Option<crate::models::SparkInvoiceFields>>::sse_decode(deserializer);
        let mut var_signature = <Option<String>>::sse_decode(deserializer);
        return crate::models::SparkAddress {
            identity_public_key: var_identityPublicKey,
            network: var_network,
            spark_invoice_fields: var_sparkInvoiceFields,
            signature: var_signature,
        };
    }
}

impl SseDecode for crate::models::SparkAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_decodedAddress = <crate::models::SparkAddress>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::SparkAddressDetails {
            address: var_address,
            decoded_address: var_decodedAddress,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::SparkAddressPaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::models::TokensPaymentDetails>::sse_decode(deserializer);
                return crate::models::SparkAddressPaymentType::TokensPayment(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::models::SatsPaymentDetails>::sse_decode(deserializer);
                return crate::models::SparkAddressPaymentType::SatsPayment(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SparkInvoiceFields {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_memo = <Option<String>>::sse_decode(deserializer);
        let mut var_senderPublicKey = <Option<String>>::sse_decode(deserializer);
        let mut var_expiryTime = <Option<u64>>::sse_decode(deserializer);
        let mut var_paymentType =
            <Option<crate::models::SparkAddressPaymentType>>::sse_decode(deserializer);
        return crate::models::SparkInvoiceFields {
            id: var_id,
            version: var_version,
            memo: var_memo,
            sender_public_key: var_senderPublicKey,
            expiry_time: var_expiryTime,
            payment_type: var_paymentType,
        };
    }
}

impl SseDecode for crate::models::SuccessAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data = <crate::models::AesSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Aes { data: var_data };
            }
            1 => {
                let mut var_data =
                    <crate::models::MessageSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Message { data: var_data };
            }
            2 => {
                let mut var_data = <crate::models::UrlSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Url { data: var_data };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SuccessActionProcessed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_result =
                    <crate::models::AesSuccessActionDataResult>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Aes { result: var_result };
            }
            1 => {
                let mut var_data =
                    <crate::models::MessageSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Message { data: var_data };
            }
            2 => {
                let mut var_data = <crate::models::UrlSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Url { data: var_data };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Symbol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_grapheme = <Option<String>>::sse_decode(deserializer);
        let mut var_template = <Option<String>>::sse_decode(deserializer);
        let mut var_rtl = <Option<bool>>::sse_decode(deserializer);
        let mut var_position = <Option<u32>>::sse_decode(deserializer);
        return crate::models::Symbol {
            grapheme: var_grapheme,
            template: var_template,
            rtl: var_rtl,
            position: var_position,
        };
    }
}

impl SseDecode for crate::models::SyncWalletRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::SyncWalletRequest {};
    }
}

impl SseDecode for crate::models::SyncWalletResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::SyncWalletResponse {};
    }
}

impl SseDecode for crate::models::TokenBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_balance = <u128>::sse_decode(deserializer);
        let mut var_tokenMetadata = <crate::models::TokenMetadata>::sse_decode(deserializer);
        return crate::models::TokenBalance {
            balance: var_balance,
            token_metadata: var_tokenMetadata,
        };
    }
}

impl SseDecode for crate::models::TokenMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_identifier = <String>::sse_decode(deserializer);
        let mut var_issuerPublicKey = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_ticker = <String>::sse_decode(deserializer);
        let mut var_decimals = <u32>::sse_decode(deserializer);
        let mut var_maxSupply = <u128>::sse_decode(deserializer);
        let mut var_isFreezable = <bool>::sse_decode(deserializer);
        return crate::models::TokenMetadata {
            identifier: var_identifier,
            issuer_public_key: var_issuerPublicKey,
            name: var_name,
            ticker: var_ticker,
            decimals: var_decimals,
            max_supply: var_maxSupply,
            is_freezable: var_isFreezable,
        };
    }
}

impl SseDecode for crate::models::TokensPaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        let mut var_amount = <Option<u128>>::sse_decode(deserializer);
        return crate::models::TokensPaymentDetails {
            token_identifier: var_tokenIdentifier,
            amount: var_amount,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::models::UrlSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_matchesCallbackDomain = <bool>::sse_decode(deserializer);
        return crate::models::UrlSuccessActionData {
            description: var_description,
            url: var_url,
            matches_callback_domain: var_matchesCallbackDomain,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::models::WaitForPaymentIdentifier {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::models::WaitForPaymentIdentifier::PaymentId(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::models::WaitForPaymentIdentifier::PaymentRequest(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::WaitForPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_identifier =
            <crate::models::WaitForPaymentIdentifier>::sse_decode(deserializer);
        return crate::models::WaitForPaymentRequest {
            identifier: var_identifier,
        };
    }
}

impl SseDecode for crate::models::WaitForPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::WaitForPaymentResponse {
            payment: var_payment,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__sdk__BreezSdk_add_event_listener_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__sdk__BreezSdk_check_lightning_address_available_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__sdk__BreezSdk_claim_deposit_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__sdk__BreezSdk_delete_lightning_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__sdk__BreezSdk_disconnect_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__sdk__BreezSdk_get_info_impl(port, ptr, rust_vec_len, data_len),
        7 => {
            wire__crate__sdk__BreezSdk_get_lightning_address_impl(port, ptr, rust_vec_len, data_len)
        }
        8 => wire__crate__sdk__BreezSdk_get_payment_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__sdk__BreezSdk_get_tokens_metadata_impl(port, ptr, rust_vec_len, data_len),
        10 => {
            wire__crate__sdk__BreezSdk_list_fiat_currencies_impl(port, ptr, rust_vec_len, data_len)
        }
        11 => wire__crate__sdk__BreezSdk_list_fiat_rates_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__sdk__BreezSdk_list_payments_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__sdk__BreezSdk_list_unclaimed_deposits_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__sdk__BreezSdk_lnurl_pay_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__sdk__BreezSdk_prepare_lnurl_pay_impl(port, ptr, rust_vec_len, data_len),
        16 => {
            wire__crate__sdk__BreezSdk_prepare_send_payment_impl(port, ptr, rust_vec_len, data_len)
        }
        17 => wire__crate__sdk__BreezSdk_receive_payment_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__sdk__BreezSdk_refund_deposit_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__sdk__BreezSdk_register_lightning_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        20 => {
            wire__crate__sdk__BreezSdk_remove_event_listener_impl(port, ptr, rust_vec_len, data_len)
        }
        21 => wire__crate__sdk__BreezSdk_send_payment_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__sdk__BreezSdk_sync_wallet_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__sdk__BreezSdk_wait_for_payment_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__sdk_builder__SdkBuilder_build_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__sdk__connect_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__sdk__parse_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        25 => wire__crate__sdk_builder__SdkBuilder_new_impl(ptr, rust_vec_len, data_len),
        26 => wire__crate__sdk_builder__SdkBuilder_with_key_set_impl(ptr, rust_vec_len, data_len),
        27 => wire__crate__sdk_builder__SdkBuilder_with_rest_chain_service_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__sdk__default_config_impl(ptr, rust_vec_len, data_len),
        30 => wire__crate__sdk__default_storage_impl(ptr, rust_vec_len, data_len),
        31 => wire__crate__sdk__init_logging_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<dyn Storage>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<dyn Storage>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<dyn Storage>>> for Arc<dyn Storage> {
    fn into_into_dart(self) -> FrbWrapper<Arc<dyn Storage>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BreezSdk> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BreezSdk> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BreezSdk>> for BreezSdk {
    fn into_into_dart(self) -> FrbWrapper<BreezSdk> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SdkBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SdkBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SdkBuilder>> for SdkBuilder {
    fn into_into_dart(self) -> FrbWrapper<SdkBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.ciphertext.into_into_dart().into_dart(),
            self.0.iv.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionData>>
    for crate::models::AesSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionDataDecrypted> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.plaintext.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionDataDecrypted>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionDataDecrypted>>
    for crate::models::AesSuccessActionDataDecrypted
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionDataDecrypted> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionDataResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::AesSuccessActionDataResult::Decrypted { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
                [1.into_dart(), reason.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionDataResult>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionDataResult>>
    for crate::models::AesSuccessActionDataResult
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionDataResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Amount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Amount::Bitcoin { amount_msat } => {
                [0.into_dart(), amount_msat.into_into_dart().into_dart()].into_dart()
            }
            crate::models::Amount::Currency {
                iso4217_code,
                fractional_amount,
            } => [
                1.into_dart(),
                iso4217_code.into_into_dart().into_dart(),
                fractional_amount.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Amount>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Amount>>
    for crate::models::Amount
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Amount> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AssetFilter> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::AssetFilter::Bitcoin => [0.into_dart()].into_dart(),
            crate::models::AssetFilter::Token { token_identifier } => {
                [1.into_dart(), token_identifier.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AssetFilter>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AssetFilter>>
    for crate::models::AssetFilter
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AssetFilter> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bip21Details> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sat.into_into_dart().into_dart(),
            self.0.asset_id.into_into_dart().into_dart(),
            self.0.uri.into_into_dart().into_dart(),
            self.0.extras.into_into_dart().into_dart(),
            self.0.label.into_into_dart().into_dart(),
            self.0.message.into_into_dart().into_dart(),
            self.0.payment_methods.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bip21Details>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bip21Details>>
    for crate::models::Bip21Details
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bip21Details> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bip21Extra> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.key.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bip21Extra>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bip21Extra>>
    for crate::models::Bip21Extra
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bip21Extra> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::BitcoinAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::BitcoinAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::BitcoinAddressDetails>>
    for crate::models::BitcoinAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::BitcoinAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::BitcoinNetwork> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::BitcoinNetwork::Bitcoin => 0.into_dart(),
            crate::models::BitcoinNetwork::Testnet3 => 1.into_dart(),
            crate::models::BitcoinNetwork::Testnet4 => 2.into_dart(),
            crate::models::BitcoinNetwork::Signet => 3.into_dart(),
            crate::models::BitcoinNetwork::Regtest => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::BitcoinNetwork>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::BitcoinNetwork>>
    for crate::models::BitcoinNetwork
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::BitcoinNetwork> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bolt11.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11Invoice>>
    for crate::models::Bolt11Invoice
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11InvoiceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_msat.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
            self.0.description_hash.into_into_dart().into_dart(),
            self.0.expiry.into_into_dart().into_dart(),
            self.0.invoice.into_into_dart().into_dart(),
            self.0
                .min_final_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.payee_pubkey.into_into_dart().into_dart(),
            self.0.payment_hash.into_into_dart().into_dart(),
            self.0.payment_secret.into_into_dart().into_dart(),
            self.0.routing_hints.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11InvoiceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11InvoiceDetails>>
    for crate::models::Bolt11InvoiceDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11InvoiceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11RouteHint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hops.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11RouteHint>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11RouteHint>>
    for crate::models::Bolt11RouteHint
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11RouteHint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11RouteHintHop> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.src_node_id.into_into_dart().into_dart(),
            self.0.short_channel_id.into_into_dart().into_dart(),
            self.0.fees_base_msat.into_into_dart().into_dart(),
            self.0
                .fees_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.0.cltv_expiry_delta.into_into_dart().into_dart(),
            self.0.htlc_minimum_msat.into_into_dart().into_dart(),
            self.0.htlc_maximum_msat.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11RouteHintHop>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11RouteHintHop>>
    for crate::models::Bolt11RouteHintHop
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11RouteHintHop> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.invoice.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12Invoice>>
    for crate::models::Bolt12Invoice
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12InvoiceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_msat.into_into_dart().into_dart(),
            self.0.invoice.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12InvoiceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12InvoiceDetails>>
    for crate::models::Bolt12InvoiceDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12InvoiceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12InvoiceRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12InvoiceRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12InvoiceRequestDetails>>
    for crate::models::Bolt12InvoiceRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12InvoiceRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12Offer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.offer.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12Offer>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12Offer>>
    for crate::models::Bolt12Offer
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12Offer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12OfferBlindedPath> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.blinded_hops.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12OfferBlindedPath>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12OfferBlindedPath>>
    for crate::models::Bolt12OfferBlindedPath
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12OfferBlindedPath> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12OfferDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.absolute_expiry.into_into_dart().into_dart(),
            self.0.chains.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
            self.0.issuer.into_into_dart().into_dart(),
            self.0.min_amount.into_into_dart().into_dart(),
            self.0.offer.into_into_dart().into_dart(),
            self.0.paths.into_into_dart().into_dart(),
            self.0.signing_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12OfferDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12OfferDetails>>
    for crate::models::Bolt12OfferDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12OfferDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CheckLightningAddressRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.username.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CheckLightningAddressRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CheckLightningAddressRequest>>
    for crate::models::CheckLightningAddressRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CheckLightningAddressRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimDepositRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.max_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimDepositRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimDepositRequest>>
    for crate::models::ClaimDepositRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimDepositRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimDepositResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimDepositResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimDepositResponse>>
    for crate::models::ClaimDepositResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimDepositResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Config> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.api_key.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.sync_interval_secs.into_into_dart().into_dart(),
            self.0.max_deposit_claim_fee.into_into_dart().into_dart(),
            self.0.lnurl_domain.into_into_dart().into_dart(),
            self.0
                .prefer_spark_over_lightning
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Config>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Config>>
    for crate::models::Config
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Config> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConnectRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.config.into_into_dart().into_dart(),
            self.0.seed.into_into_dart().into_dart(),
            self.0.storage_dir.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConnectRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConnectRequest>>
    for crate::models::ConnectRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConnectRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Credentials> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.username.into_into_dart().into_dart(),
            self.0.password.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Credentials>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Credentials>>
    for crate::models::Credentials
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Credentials> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CurrencyInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.fraction_size.into_into_dart().into_dart(),
            self.0.spacing.into_into_dart().into_dart(),
            self.0.symbol.into_into_dart().into_dart(),
            self.0.uniq_symbol.into_into_dart().into_dart(),
            self.0.localized_name.into_into_dart().into_dart(),
            self.0.locale_overrides.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CurrencyInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CurrencyInfo>>
    for crate::models::CurrencyInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CurrencyInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::errors::DepositClaimError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::errors::DepositClaimError::DepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                actual_fee,
            } => [
                0.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
                max_fee.into_into_dart().into_dart(),
                actual_fee.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::DepositClaimError::MissingUtxo { tx, vout } => [
                1.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::DepositClaimError::Generic { message } => {
                [2.into_dart(), message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::errors::DepositClaimError>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::errors::DepositClaimError>>
    for crate::errors::DepositClaimError
{
    fn into_into_dart(self) -> FrbWrapper<crate::errors::DepositClaimError> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::DepositInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.refund_tx.into_into_dart().into_dart(),
            self.0.refund_tx_id.into_into_dart().into_dart(),
            self.0.claim_error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::DepositInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::DepositInfo>>
    for crate::models::DepositInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::DepositInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Fee> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Fee::Fixed { amount } => {
                [0.into_dart(), amount.into_into_dart().into_dart()].into_dart()
            }
            crate::models::Fee::Rate { sat_per_vbyte } => {
                [1.into_dart(), sat_per_vbyte.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Fee>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Fee>> for crate::models::Fee {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Fee> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FiatCurrency> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FiatCurrency>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FiatCurrency>>
    for crate::models::FiatCurrency
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetInfoRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.ensure_synced.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetInfoRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetInfoRequest>>
    for crate::models::GetInfoRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetInfoRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetInfoResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.balance_sats.into_into_dart().into_dart(),
            self.0.token_balances.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetInfoResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetInfoResponse>>
    for crate::models::GetInfoResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetInfoResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment_id.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetPaymentRequest>>
    for crate::models::GetPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetPaymentResponse>>
    for crate::models::GetPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetTokensMetadataRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.token_identifiers.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetTokensMetadataRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetTokensMetadataRequest>>
    for crate::models::GetTokensMetadataRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetTokensMetadataRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetTokensMetadataResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.tokens_metadata.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetTokensMetadataResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetTokensMetadataResponse>>
    for crate::models::GetTokensMetadataResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetTokensMetadataResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::InputType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::InputType::BitcoinAddress(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt11Invoice(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12Invoice(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12Offer(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LightningAddress(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlPay(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::SilentPaymentAddress(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlAuth(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Url(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bip21(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12InvoiceRequest(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlWithdraw(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::SparkAddress(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::InputType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::InputType>>
    for crate::models::InputType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::InputType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::KeySetType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::KeySetType::Default => 0.into_dart(),
            crate::models::KeySetType::Taproot => 1.into_dart(),
            crate::models::KeySetType::NativeSegwit => 2.into_dart(),
            crate::models::KeySetType::WrappedSegwit => 3.into_dart(),
            crate::models::KeySetType::Legacy => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::KeySetType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::KeySetType>>
    for crate::models::KeySetType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::KeySetType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LightningAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LightningAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LightningAddressDetails>>
    for crate::models::LightningAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LightningAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LightningAddressInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.lightning_address.into_into_dart().into_dart(),
            self.0.lnurl.into_into_dart().into_dart(),
            self.0.username.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LightningAddressInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LightningAddressInfo>>
    for crate::models::LightningAddressInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LightningAddressInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListFiatCurrenciesResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.currencies.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListFiatCurrenciesResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListFiatCurrenciesResponse>>
    for crate::models::ListFiatCurrenciesResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListFiatCurrenciesResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListFiatRatesResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.rates.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListFiatRatesResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListFiatRatesResponse>>
    for crate::models::ListFiatRatesResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListFiatRatesResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListPaymentsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.type_filter.into_into_dart().into_dart(),
            self.0.status_filter.into_into_dart().into_dart(),
            self.0.asset_filter.into_into_dart().into_dart(),
            self.0.from_timestamp.into_into_dart().into_dart(),
            self.0.to_timestamp.into_into_dart().into_dart(),
            self.0.offset.into_into_dart().into_dart(),
            self.0.limit.into_into_dart().into_dart(),
            self.0.sort_ascending.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListPaymentsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListPaymentsRequest>>
    for crate::models::ListPaymentsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListPaymentsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListPaymentsResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payments.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListPaymentsResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListPaymentsResponse>>
    for crate::models::ListPaymentsResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListPaymentsResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListUnclaimedDepositsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListUnclaimedDepositsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListUnclaimedDepositsRequest>>
    for crate::models::ListUnclaimedDepositsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListUnclaimedDepositsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListUnclaimedDepositsResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.deposits.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListUnclaimedDepositsResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListUnclaimedDepositsResponse>>
    for crate::models::ListUnclaimedDepositsResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListUnclaimedDepositsResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlAuthRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.k1.into_into_dart().into_dart(),
            self.0.action.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlAuthRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlAuthRequestDetails>>
    for crate::models::LnurlAuthRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlAuthRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ln_address.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.metadata.into_into_dart().into_dart(),
            self.0.processed_success_action.into_into_dart().into_dart(),
            self.0.raw_success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayInfo>>
    for crate::models::LnurlPayInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.prepare_response.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayRequest>>
    for crate::models::LnurlPayRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.callback.into_into_dart().into_dart(),
            self.0.min_sendable.into_into_dart().into_dart(),
            self.0.max_sendable.into_into_dart().into_dart(),
            self.0.metadata_str.into_into_dart().into_dart(),
            self.0.comment_allowed.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.address.into_into_dart().into_dart(),
            self.0.allows_nostr.into_into_dart().into_dart(),
            self.0.nostr_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayRequestDetails>>
    for crate::models::LnurlPayRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment.into_into_dart().into_dart(),
            self.0.success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayResponse>>
    for crate::models::LnurlPayResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlWithdrawRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.callback.into_into_dart().into_dart(),
            self.0.k1.into_into_dart().into_dart(),
            self.0.default_description.into_into_dart().into_dart(),
            self.0.min_withdrawable.into_into_dart().into_dart(),
            self.0.max_withdrawable.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlWithdrawRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlWithdrawRequestDetails>>
    for crate::models::LnurlWithdrawRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlWithdrawRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LocaleOverrides> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.locale.into_into_dart().into_dart(),
            self.0.spacing.into_into_dart().into_dart(),
            self.0.symbol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LocaleOverrides>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LocaleOverrides>>
    for crate::models::LocaleOverrides
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LocaleOverrides> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LocalizedName> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.locale.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LocalizedName>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LocalizedName>>
    for crate::models::LocalizedName
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LocalizedName> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::logger::LogEntry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.line.into_into_dart().into_dart(),
            self.0.level.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::logger::LogEntry>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::logger::LogEntry>>
    for crate::logger::LogEntry
{
    fn into_into_dart(self) -> FrbWrapper<crate::logger::LogEntry> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::MessageSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.message.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::MessageSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::MessageSuccessActionData>>
    for crate::models::MessageSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::MessageSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Network::Mainnet => 0.into_dart(),
            crate::models::Network::Regtest => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Network>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Network>>
    for crate::models::Network
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::OnchainConfirmationSpeed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::OnchainConfirmationSpeed::Fast => 0.into_dart(),
            crate::models::OnchainConfirmationSpeed::Medium => 1.into_dart(),
            crate::models::OnchainConfirmationSpeed::Slow => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::OnchainConfirmationSpeed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::OnchainConfirmationSpeed>>
    for crate::models::OnchainConfirmationSpeed
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::OnchainConfirmationSpeed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.payment_type.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.fees.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
            self.0.method.into_into_dart().into_dart(),
            self.0.details.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Payment>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Payment>>
    for crate::models::Payment
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Payment> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentDetails::Spark => [0.into_dart()].into_dart(),
            crate::models::PaymentDetails::Token { metadata, tx_hash } => [
                1.into_dart(),
                metadata.into_into_dart().into_dart(),
                tx_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetails::Lightning {
                description,
                preimage,
                invoice,
                payment_hash,
                destination_pubkey,
                lnurl_pay_info,
            } => [
                2.into_dart(),
                description.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                invoice.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                destination_pubkey.into_into_dart().into_dart(),
                lnurl_pay_info.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetails::Withdraw { tx_id } => {
                [3.into_dart(), tx_id.into_into_dart().into_dart()].into_dart()
            }
            crate::models::PaymentDetails::Deposit { tx_id } => {
                [4.into_dart(), tx_id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentDetails>>
    for crate::models::PaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentMethod::Lightning => 0.into_dart(),
            crate::models::PaymentMethod::Spark => 1.into_dart(),
            crate::models::PaymentMethod::Token => 2.into_dart(),
            crate::models::PaymentMethod::Deposit => 3.into_dart(),
            crate::models::PaymentMethod::Withdraw => 4.into_dart(),
            crate::models::PaymentMethod::Unknown => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentMethod>>
    for crate::models::PaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentRequestSource> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bip_21_uri.into_into_dart().into_dart(),
            self.0.bip_353_address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentRequestSource>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentRequestSource>>
    for crate::models::PaymentRequestSource
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentRequestSource> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentStatus::Completed => 0.into_dart(),
            crate::models::PaymentStatus::Pending => 1.into_dart(),
            crate::models::PaymentStatus::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentStatus>>
    for crate::models::PaymentStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentType::Send => 0.into_dart(),
            crate::models::PaymentType::Receive => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentType>>
    for crate::models::PaymentType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareLnurlPayRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0
                .validate_success_action_url
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareLnurlPayRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareLnurlPayRequest>>
    for crate::models::PrepareLnurlPayRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareLnurlPayRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareLnurlPayResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
            self.0.fee_sats.into_into_dart().into_dart(),
            self.0.invoice_details.into_into_dart().into_dart(),
            self.0.success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareLnurlPayResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareLnurlPayResponse>>
    for crate::models::PrepareLnurlPayResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareLnurlPayResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareSendPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_request.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareSendPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareSendPaymentRequest>>
    for crate::models::PrepareSendPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareSendPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareSendPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_method.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareSendPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareSendPaymentResponse>>
    for crate::models::PrepareSendPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareSendPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Rate> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.coin.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Rate>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Rate>> for crate::models::Rate {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Rate> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ReceivePaymentMethod::SparkAddress => [0.into_dart()].into_dart(),
            crate::models::ReceivePaymentMethod::BitcoinAddress => [1.into_dart()].into_dart(),
            crate::models::ReceivePaymentMethod::Bolt11Invoice {
                description,
                amount_sats,
            } => [
                2.into_dart(),
                description.into_into_dart().into_dart(),
                amount_sats.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentMethod>>
    for crate::models::ReceivePaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment_method.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentRequest>>
    for crate::models::ReceivePaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_request.into_into_dart().into_dart(),
            self.0.fee_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentResponse>>
    for crate::models::ReceivePaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RefundDepositRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.destination_address.into_into_dart().into_dart(),
            self.0.fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RefundDepositRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RefundDepositRequest>>
    for crate::models::RefundDepositRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RefundDepositRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RefundDepositResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.tx_id.into_into_dart().into_dart(),
            self.0.tx_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RefundDepositResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RefundDepositResponse>>
    for crate::models::RefundDepositResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RefundDepositResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RegisterLightningAddressRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.username.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RegisterLightningAddressRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RegisterLightningAddressRequest>>
    for crate::models::RegisterLightningAddressRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RegisterLightningAddressRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SatsPaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.amount.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SatsPaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SatsPaymentDetails>>
    for crate::models::SatsPaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SatsPaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::errors::SdkError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::errors::SdkError::SparkError(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::InvalidUuid(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::InvalidInput(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::NetworkError(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::StorageError(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::ChainServiceError(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::DepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                actual_fee,
            } => [
                6.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
                max_fee.into_into_dart().into_dart(),
                actual_fee.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::SdkError::MissingUtxo { tx, vout } => [
                7.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::SdkError::LnurlError(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::Generic(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::errors::SdkError>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::errors::SdkError>>
    for crate::errors::SdkError
{
    fn into_into_dart(self) -> FrbWrapper<crate::errors::SdkError> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::events::SdkEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::events::SdkEvent::Synced => [0.into_dart()].into_dart(),
            crate::events::SdkEvent::ClaimDepositsFailed { unclaimed_deposits } => [
                1.into_dart(),
                unclaimed_deposits.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::events::SdkEvent::ClaimDepositsSucceeded { claimed_deposits } => {
                [2.into_dart(), claimed_deposits.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::PaymentSucceeded { payment } => {
                [3.into_dart(), payment.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::PaymentFailed { payment } => {
                [4.into_dart(), payment.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::events::SdkEvent>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::events::SdkEvent>>
    for crate::events::SdkEvent
{
    fn into_into_dart(self) -> FrbWrapper<crate::events::SdkEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Seed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Seed::Mnemonic {
                mnemonic,
                passphrase,
            } => [
                0.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::Seed::Entropy(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Seed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Seed>> for crate::models::Seed {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Seed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendOnchainFeeQuote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.expires_at.into_into_dart().into_dart(),
            self.0.speed_fast.into_into_dart().into_dart(),
            self.0.speed_medium.into_into_dart().into_dart(),
            self.0.speed_slow.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendOnchainFeeQuote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendOnchainFeeQuote>>
    for crate::models::SendOnchainFeeQuote
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendOnchainFeeQuote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendOnchainSpeedFeeQuote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.user_fee_sat.into_into_dart().into_dart(),
            self.0.l1_broadcast_fee_sat.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendOnchainSpeedFeeQuote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendOnchainSpeedFeeQuote>>
    for crate::models::SendOnchainSpeedFeeQuote
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendOnchainSpeedFeeQuote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => [
                0.into_dart(),
                address.into_into_dart().into_dart(),
                fee_quote.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentMethod::Bolt11Invoice {
                invoice_details,
                spark_transfer_fee_sats,
                lightning_fee_sats,
            } => [
                1.into_dart(),
                invoice_details.into_into_dart().into_dart(),
                spark_transfer_fee_sats.into_into_dart().into_dart(),
                lightning_fee_sats.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentMethod::SparkAddress {
                address,
                fee,
                token_identifier,
            } => [
                2.into_dart(),
                address.into_into_dart().into_dart(),
                fee.into_into_dart().into_dart(),
                token_identifier.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentMethod>>
    for crate::models::SendPaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => [
                0.into_dart(),
                confirmation_speed.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentOptions::Bolt11Invoice {
                prefer_spark,
                completion_timeout_secs,
            } => [
                1.into_dart(),
                prefer_spark.into_into_dart().into_dart(),
                completion_timeout_secs.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentOptions>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentOptions>>
    for crate::models::SendPaymentOptions
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentOptions> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.prepare_response.into_into_dart().into_dart(),
            self.0.options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentRequest>>
    for crate::models::SendPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentResponse>>
    for crate::models::SendPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SilentPaymentAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SilentPaymentAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SilentPaymentAddressDetails>>
    for crate::models::SilentPaymentAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SilentPaymentAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.identity_public_key.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.spark_invoice_fields.into_into_dart().into_dart(),
            self.0.signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkAddress>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkAddress>>
    for crate::models::SparkAddress
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkAddress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.decoded_address.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkAddressDetails>>
    for crate::models::SparkAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkAddressPaymentType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SparkAddressPaymentType::TokensPayment(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SparkAddressPaymentType::SatsPayment(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkAddressPaymentType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkAddressPaymentType>>
    for crate::models::SparkAddressPaymentType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkAddressPaymentType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkInvoiceFields> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
            self.0.memo.into_into_dart().into_dart(),
            self.0.sender_public_key.into_into_dart().into_dart(),
            self.0.expiry_time.into_into_dart().into_dart(),
            self.0.payment_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkInvoiceFields>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkInvoiceFields>>
    for crate::models::SparkInvoiceFields
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkInvoiceFields> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SuccessAction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SuccessAction::Aes { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessAction::Message { data } => {
                [1.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessAction::Url { data } => {
                [2.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SuccessAction>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SuccessAction>>
    for crate::models::SuccessAction
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SuccessAction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SuccessActionProcessed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SuccessActionProcessed::Aes { result } => {
                [0.into_dart(), result.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessActionProcessed::Message { data } => {
                [1.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessActionProcessed::Url { data } => {
                [2.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SuccessActionProcessed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SuccessActionProcessed>>
    for crate::models::SuccessActionProcessed
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SuccessActionProcessed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Symbol> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.grapheme.into_into_dart().into_dart(),
            self.0.template.into_into_dart().into_dart(),
            self.0.rtl.into_into_dart().into_dart(),
            self.0.position.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Symbol>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Symbol>>
    for crate::models::Symbol
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Symbol> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SyncWalletRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SyncWalletRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SyncWalletRequest>>
    for crate::models::SyncWalletRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SyncWalletRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SyncWalletResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SyncWalletResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SyncWalletResponse>>
    for crate::models::SyncWalletResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SyncWalletResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::TokenBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.balance.into_into_dart().into_dart(),
            self.0.token_metadata.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::TokenBalance>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::TokenBalance>>
    for crate::models::TokenBalance
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::TokenBalance> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::TokenMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.identifier.into_into_dart().into_dart(),
            self.0.issuer_public_key.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.ticker.into_into_dart().into_dart(),
            self.0.decimals.into_into_dart().into_dart(),
            self.0.max_supply.into_into_dart().into_dart(),
            self.0.is_freezable.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::TokenMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::TokenMetadata>>
    for crate::models::TokenMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::TokenMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::TokensPaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.token_identifier.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::TokensPaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::TokensPaymentDetails>>
    for crate::models::TokensPaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::TokensPaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UrlSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.matches_callback_domain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UrlSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UrlSuccessActionData>>
    for crate::models::UrlSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UrlSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::WaitForPaymentIdentifier> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::WaitForPaymentIdentifier::PaymentId(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::WaitForPaymentIdentifier::PaymentRequest(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::WaitForPaymentIdentifier>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::WaitForPaymentIdentifier>>
    for crate::models::WaitForPaymentIdentifier
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::WaitForPaymentIdentifier> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::WaitForPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.identifier.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::WaitForPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::WaitForPaymentRequest>>
    for crate::models::WaitForPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::WaitForPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::WaitForPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::WaitForPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::WaitForPaymentResponse>>
    for crate::models::WaitForPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::WaitForPaymentResponse> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for Arc<dyn Storage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Storage >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for BreezSdk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for SdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, crate::models::TokenBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::models::TokenBalance)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<dyn Storage>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::events::SdkEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.ciphertext, serializer);
        <String>::sse_encode(self.iv, serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionDataDecrypted {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.plaintext, serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionDataResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::AesSuccessActionDataResult::Decrypted { data } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionDataDecrypted>::sse_encode(data, serializer);
            }
            crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(reason, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Amount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Amount::Bitcoin { amount_msat } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::models::Amount::Currency {
                iso4217_code,
                fractional_amount,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(iso4217_code, serializer);
                <u64>::sse_encode(fractional_amount, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::AssetFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::AssetFilter::Bitcoin => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::AssetFilter::Token { token_identifier } => {
                <i32>::sse_encode(1, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Bip21Details {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.amount_sat, serializer);
        <Option<String>>::sse_encode(self.asset_id, serializer);
        <String>::sse_encode(self.uri, serializer);
        <Vec<crate::models::Bip21Extra>>::sse_encode(self.extras, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <Option<String>>::sse_encode(self.message, serializer);
        <Vec<crate::models::InputType>>::sse_encode(self.payment_methods, serializer);
    }
}

impl SseEncode for crate::models::Bip21Extra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.key, serializer);
        <String>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::BitcoinAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::BitcoinNetwork {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::BitcoinNetwork::Bitcoin => 0,
                crate::models::BitcoinNetwork::Testnet3 => 1,
                crate::models::BitcoinNetwork::Testnet4 => 2,
                crate::models::BitcoinNetwork::Signet => 3,
                crate::models::BitcoinNetwork::Regtest => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.bolt11, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt11InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<String>>::sse_encode(self.description_hash, serializer);
        <u64>::sse_encode(self.expiry, serializer);
        <crate::models::Bolt11Invoice>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.min_final_cltv_expiry_delta, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <String>::sse_encode(self.payee_pubkey, serializer);
        <String>::sse_encode(self.payment_hash, serializer);
        <String>::sse_encode(self.payment_secret, serializer);
        <Vec<crate::models::Bolt11RouteHint>>::sse_encode(self.routing_hints, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::models::Bolt11RouteHint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Bolt11RouteHintHop>>::sse_encode(self.hops, serializer);
    }
}

impl SseEncode for crate::models::Bolt11RouteHintHop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.src_node_id, serializer);
        <String>::sse_encode(self.short_channel_id, serializer);
        <u32>::sse_encode(self.fees_base_msat, serializer);
        <u32>::sse_encode(self.fees_proportional_millionths, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <Option<u64>>::sse_encode(self.htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.htlc_maximum_msat, serializer);
    }
}

impl SseEncode for crate::models::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.invoice, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt12InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_msat, serializer);
        <crate::models::Bolt12Invoice>::sse_encode(self.invoice, serializer);
    }
}

impl SseEncode for crate::models::Bolt12InvoiceRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::Bolt12Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.offer, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt12OfferBlindedPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.blinded_hops, serializer);
    }
}

impl SseEncode for crate::models::Bolt12OfferDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.absolute_expiry, serializer);
        <Vec<String>>::sse_encode(self.chains, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<String>>::sse_encode(self.issuer, serializer);
        <Option<crate::models::Amount>>::sse_encode(self.min_amount, serializer);
        <crate::models::Bolt12Offer>::sse_encode(self.offer, serializer);
        <Vec<crate::models::Bolt12OfferBlindedPath>>::sse_encode(self.paths, serializer);
        <Option<String>>::sse_encode(self.signing_pubkey, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::CheckLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
    }
}

impl SseEncode for crate::models::ClaimDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <Option<crate::models::Fee>>::sse_encode(self.max_fee, serializer);
    }
}

impl SseEncode for crate::models::ClaimDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.api_key, serializer);
        <crate::models::Network>::sse_encode(self.network, serializer);
        <u32>::sse_encode(self.sync_interval_secs, serializer);
        <Option<crate::models::Fee>>::sse_encode(self.max_deposit_claim_fee, serializer);
        <Option<String>>::sse_encode(self.lnurl_domain, serializer);
        <bool>::sse_encode(self.prefer_spark_over_lightning, serializer);
    }
}

impl SseEncode for crate::models::ConnectRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Config>::sse_encode(self.config, serializer);
        <crate::models::Seed>::sse_encode(self.seed, serializer);
        <String>::sse_encode(self.storage_dir, serializer);
    }
}

impl SseEncode for crate::models::Credentials {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.password, serializer);
    }
}

impl SseEncode for crate::models::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.fraction_size, serializer);
        <Option<u32>>::sse_encode(self.spacing, serializer);
        <Option<crate::models::Symbol>>::sse_encode(self.symbol, serializer);
        <Option<crate::models::Symbol>>::sse_encode(self.uniq_symbol, serializer);
        <Vec<crate::models::LocalizedName>>::sse_encode(self.localized_name, serializer);
        <Vec<crate::models::LocaleOverrides>>::sse_encode(self.locale_overrides, serializer);
    }
}

impl SseEncode for crate::errors::DepositClaimError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::errors::DepositClaimError::DepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                actual_fee,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
                <crate::models::Fee>::sse_encode(max_fee, serializer);
                <u64>::sse_encode(actual_fee, serializer);
            }
            crate::errors::DepositClaimError::MissingUtxo { tx, vout } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
            }
            crate::errors::DepositClaimError::Generic { message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::DepositInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
        <Option<String>>::sse_encode(self.refund_tx, serializer);
        <Option<String>>::sse_encode(self.refund_tx_id, serializer);
        <Option<crate::errors::DepositClaimError>>::sse_encode(self.claim_error, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Fee::Fixed { amount } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(amount, serializer);
            }
            crate::models::Fee::Rate { sat_per_vbyte } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(sat_per_vbyte, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::models::CurrencyInfo>::sse_encode(self.info, serializer);
    }
}

impl SseEncode for crate::models::GetInfoRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<bool>>::sse_encode(self.ensure_synced, serializer);
    }
}

impl SseEncode for crate::models::GetInfoResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.balance_sats, serializer);
        <std::collections::HashMap<String, crate::models::TokenBalance>>::sse_encode(
            self.token_balances,
            serializer,
        );
    }
}

impl SseEncode for crate::models::GetPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_id, serializer);
    }
}

impl SseEncode for crate::models::GetPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::GetTokensMetadataRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.token_identifiers, serializer);
    }
}

impl SseEncode for crate::models::GetTokensMetadataResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::TokenMetadata>>::sse_encode(self.tokens_metadata, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::InputType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::InputType::BitcoinAddress(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::models::BitcoinAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt11Invoice(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::models::Bolt11InvoiceDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12Invoice(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::models::Bolt12InvoiceDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12Offer(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::models::Bolt12OfferDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LightningAddress(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::models::LightningAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlPay(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::models::LnurlPayRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::SilentPaymentAddress(field0) => {
                <i32>::sse_encode(6, serializer);
                <crate::models::SilentPaymentAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlAuth(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::models::LnurlAuthRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Url(field0) => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bip21(field0) => {
                <i32>::sse_encode(9, serializer);
                <crate::models::Bip21Details>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12InvoiceRequest(field0) => {
                <i32>::sse_encode(10, serializer);
                <crate::models::Bolt12InvoiceRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlWithdraw(field0) => {
                <i32>::sse_encode(11, serializer);
                <crate::models::LnurlWithdrawRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::SparkAddress(field0) => {
                <i32>::sse_encode(12, serializer);
                <crate::models::SparkAddressDetails>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::KeySetType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::KeySetType::Default => 0,
                crate::models::KeySetType::Taproot => 1,
                crate::models::KeySetType::NativeSegwit => 2,
                crate::models::KeySetType::WrappedSegwit => 3,
                crate::models::KeySetType::Legacy => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::LightningAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
    }
}

impl SseEncode for crate::models::LightningAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.lightning_address, serializer);
        <String>::sse_encode(self.lnurl, serializer);
        <String>::sse_encode(self.username, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bip21Extra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bip21Extra>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt11RouteHint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt11RouteHint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt11RouteHintHop> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt11RouteHintHop>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt12OfferBlindedPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt12OfferBlindedPath>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::DepositInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::DepositInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListFiatCurrenciesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::FiatCurrency>>::sse_encode(self.currencies, serializer);
    }
}

impl SseEncode for Vec<crate::models::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::FiatCurrency>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListFiatRatesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Rate>>::sse_encode(self.rates, serializer);
    }
}

impl SseEncode for Vec<crate::models::InputType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::InputType>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::LocaleOverrides> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::LocaleOverrides>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::LocalizedName> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::LocalizedName>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Payment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::PaymentStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::PaymentStatus>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::PaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::PaymentType>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListPaymentsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<crate::models::PaymentType>>>::sse_encode(self.type_filter, serializer);
        <Option<Vec<crate::models::PaymentStatus>>>::sse_encode(self.status_filter, serializer);
        <Option<crate::models::AssetFilter>>::sse_encode(self.asset_filter, serializer);
        <Option<u64>>::sse_encode(self.from_timestamp, serializer);
        <Option<u64>>::sse_encode(self.to_timestamp, serializer);
        <Option<u32>>::sse_encode(self.offset, serializer);
        <Option<u32>>::sse_encode(self.limit, serializer);
        <Option<bool>>::sse_encode(self.sort_ascending, serializer);
    }
}

impl SseEncode for crate::models::ListPaymentsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Payment>>::sse_encode(self.payments, serializer);
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Rate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Rate>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::models::TokenBalance)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::models::TokenBalance)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::TokenMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::TokenMetadata>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListUnclaimedDepositsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::ListUnclaimedDepositsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::DepositInfo>>::sse_encode(self.deposits, serializer);
    }
}

impl SseEncode for crate::models::LnurlAuthRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.k1, serializer);
        <Option<String>>::sse_encode(self.action, serializer);
        <String>::sse_encode(self.domain, serializer);
        <String>::sse_encode(self.url, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.ln_address, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <Option<String>>::sse_encode(self.domain, serializer);
        <Option<String>>::sse_encode(self.metadata, serializer);
        <Option<crate::models::SuccessActionProcessed>>::sse_encode(
            self.processed_success_action,
            serializer,
        );
        <Option<crate::models::SuccessAction>>::sse_encode(self.raw_success_action, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::PrepareLnurlPayResponse>::sse_encode(self.prepare_response, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.callback, serializer);
        <u64>::sse_encode(self.min_sendable, serializer);
        <u64>::sse_encode(self.max_sendable, serializer);
        <String>::sse_encode(self.metadata_str, serializer);
        <u16>::sse_encode(self.comment_allowed, serializer);
        <String>::sse_encode(self.domain, serializer);
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.address, serializer);
        <Option<bool>>::sse_encode(self.allows_nostr, serializer);
        <Option<String>>::sse_encode(self.nostr_pubkey, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
        <Option<crate::models::SuccessActionProcessed>>::sse_encode(
            self.success_action,
            serializer,
        );
    }
}

impl SseEncode for crate::models::LnurlWithdrawRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.callback, serializer);
        <String>::sse_encode(self.k1, serializer);
        <String>::sse_encode(self.default_description, serializer);
        <u64>::sse_encode(self.min_withdrawable, serializer);
        <u64>::sse_encode(self.max_withdrawable, serializer);
    }
}

impl SseEncode for crate::models::LocaleOverrides {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.locale, serializer);
        <Option<u32>>::sse_encode(self.spacing, serializer);
        <crate::models::Symbol>::sse_encode(self.symbol, serializer);
    }
}

impl SseEncode for crate::models::LocalizedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.locale, serializer);
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.line, serializer);
        <String>::sse_encode(self.level, serializer);
    }
}

impl SseEncode for crate::models::MessageSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::models::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::Network::Mainnet => 0,
                crate::models::Network::Regtest => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::OnchainConfirmationSpeed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::OnchainConfirmationSpeed::Fast => 0,
                crate::models::OnchainConfirmationSpeed::Medium => 1,
                crate::models::OnchainConfirmationSpeed::Slow => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Amount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Amount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::AssetFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::AssetFilter>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Credentials> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Credentials>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::errors::DepositClaimError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::errors::DepositClaimError>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Fee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Fee>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LightningAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LightningAddressInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LnurlPayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LnurlPayInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SendPaymentOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SendPaymentOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SparkAddressPaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SparkAddressPaymentType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SparkInvoiceFields> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SparkInvoiceFields>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SuccessAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SuccessAction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SuccessActionProcessed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SuccessActionProcessed>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Symbol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Symbol>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::PaymentStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::PaymentStatus>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::PaymentType>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::PaymentType>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::models::PaymentType>::sse_encode(self.payment_type, serializer);
        <crate::models::PaymentStatus>::sse_encode(self.status, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <u128>::sse_encode(self.fees, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <crate::models::PaymentMethod>::sse_encode(self.method, serializer);
        <Option<crate::models::PaymentDetails>>::sse_encode(self.details, serializer);
    }
}

impl SseEncode for crate::models::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::PaymentDetails::Spark => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::PaymentDetails::Token { metadata, tx_hash } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::TokenMetadata>::sse_encode(metadata, serializer);
                <String>::sse_encode(tx_hash, serializer);
            }
            crate::models::PaymentDetails::Lightning {
                description,
                preimage,
                invoice,
                payment_hash,
                destination_pubkey,
                lnurl_pay_info,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<String>>::sse_encode(description, serializer);
                <Option<String>>::sse_encode(preimage, serializer);
                <String>::sse_encode(invoice, serializer);
                <String>::sse_encode(payment_hash, serializer);
                <String>::sse_encode(destination_pubkey, serializer);
                <Option<crate::models::LnurlPayInfo>>::sse_encode(lnurl_pay_info, serializer);
            }
            crate::models::PaymentDetails::Withdraw { tx_id } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(tx_id, serializer);
            }
            crate::models::PaymentDetails::Deposit { tx_id } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(tx_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentMethod::Lightning => 0,
                crate::models::PaymentMethod::Spark => 1,
                crate::models::PaymentMethod::Token => 2,
                crate::models::PaymentMethod::Deposit => 3,
                crate::models::PaymentMethod::Withdraw => 4,
                crate::models::PaymentMethod::Unknown => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PaymentRequestSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.bip_21_uri, serializer);
        <Option<String>>::sse_encode(self.bip_353_address, serializer);
    }
}

impl SseEncode for crate::models::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentStatus::Completed => 0,
                crate::models::PaymentStatus::Pending => 1,
                crate::models::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentType::Send => 0,
                crate::models::PaymentType::Receive => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PrepareLnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_sats, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <Option<bool>>::sse_encode(self.validate_success_action_url, serializer);
    }
}

impl SseEncode for crate::models::PrepareLnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_sats, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
        <u64>::sse_encode(self.fee_sats, serializer);
        <crate::models::Bolt11InvoiceDetails>::sse_encode(self.invoice_details, serializer);
        <Option<crate::models::SuccessAction>>::sse_encode(self.success_action, serializer);
    }
}

impl SseEncode for crate::models::PrepareSendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_request, serializer);
        <Option<u128>>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
    }
}

impl SseEncode for crate::models::PrepareSendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::SendPaymentMethod>::sse_encode(self.payment_method, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
    }
}

impl SseEncode for crate::models::Rate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.coin, serializer);
        <f64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::ReceivePaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::ReceivePaymentMethod::SparkAddress => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::ReceivePaymentMethod::BitcoinAddress => {
                <i32>::sse_encode(1, serializer);
            }
            crate::models::ReceivePaymentMethod::Bolt11Invoice {
                description,
                amount_sats,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(description, serializer);
                <Option<u64>>::sse_encode(amount_sats, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::ReceivePaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::ReceivePaymentMethod>::sse_encode(self.payment_method, serializer);
    }
}

impl SseEncode for crate::models::ReceivePaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_request, serializer);
        <u64>::sse_encode(self.fee_sats, serializer);
    }
}

impl SseEncode for (String, crate::models::TokenBalance) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::models::TokenBalance>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::models::RefundDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <String>::sse_encode(self.destination_address, serializer);
        <crate::models::Fee>::sse_encode(self.fee, serializer);
    }
}

impl SseEncode for crate::models::RefundDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tx_id, serializer);
        <String>::sse_encode(self.tx_hex, serializer);
    }
}

impl SseEncode for crate::models::RegisterLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
    }
}

impl SseEncode for crate::models::SatsPaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::errors::SdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::errors::SdkError::SparkError(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::InvalidUuid(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::InvalidInput(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::NetworkError(field0) => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::StorageError(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::ChainServiceError(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::DepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                actual_fee,
            } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
                <crate::models::Fee>::sse_encode(max_fee, serializer);
                <u64>::sse_encode(actual_fee, serializer);
            }
            crate::errors::SdkError::MissingUtxo { tx, vout } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
            }
            crate::errors::SdkError::LnurlError(field0) => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::Generic(field0) => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::events::SdkEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::events::SdkEvent::Synced => {
                <i32>::sse_encode(0, serializer);
            }
            crate::events::SdkEvent::ClaimDepositsFailed { unclaimed_deposits } => {
                <i32>::sse_encode(1, serializer);
                <Vec<crate::models::DepositInfo>>::sse_encode(unclaimed_deposits, serializer);
            }
            crate::events::SdkEvent::ClaimDepositsSucceeded { claimed_deposits } => {
                <i32>::sse_encode(2, serializer);
                <Vec<crate::models::DepositInfo>>::sse_encode(claimed_deposits, serializer);
            }
            crate::events::SdkEvent::PaymentSucceeded { payment } => {
                <i32>::sse_encode(3, serializer);
                <crate::models::Payment>::sse_encode(payment, serializer);
            }
            crate::events::SdkEvent::PaymentFailed { payment } => {
                <i32>::sse_encode(4, serializer);
                <crate::models::Payment>::sse_encode(payment, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Seed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Seed::Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
            crate::models::Seed::Entropy(field0) => {
                <i32>::sse_encode(1, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendOnchainFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u64>::sse_encode(self.expires_at, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_fast, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_medium, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_slow, serializer);
    }
}

impl SseEncode for crate::models::SendOnchainSpeedFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.user_fee_sat, serializer);
        <u64>::sse_encode(self.l1_broadcast_fee_sat, serializer);
    }
}

impl SseEncode for crate::models::SendPaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::BitcoinAddressDetails>::sse_encode(address, serializer);
                <crate::models::SendOnchainFeeQuote>::sse_encode(fee_quote, serializer);
            }
            crate::models::SendPaymentMethod::Bolt11Invoice {
                invoice_details,
                spark_transfer_fee_sats,
                lightning_fee_sats,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::Bolt11InvoiceDetails>::sse_encode(invoice_details, serializer);
                <Option<u64>>::sse_encode(spark_transfer_fee_sats, serializer);
                <u64>::sse_encode(lightning_fee_sats, serializer);
            }
            crate::models::SendPaymentMethod::SparkAddress {
                address,
                fee,
                token_identifier,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(address, serializer);
                <u128>::sse_encode(fee, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendPaymentOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::OnchainConfirmationSpeed>::sse_encode(
                    confirmation_speed,
                    serializer,
                );
            }
            crate::models::SendPaymentOptions::Bolt11Invoice {
                prefer_spark,
                completion_timeout_secs,
            } => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(prefer_spark, serializer);
                <Option<u32>>::sse_encode(completion_timeout_secs, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::PrepareSendPaymentResponse>::sse_encode(self.prepare_response, serializer);
        <Option<crate::models::SendPaymentOptions>>::sse_encode(self.options, serializer);
    }
}

impl SseEncode for crate::models::SendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::SilentPaymentAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::SparkAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.identity_public_key, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <Option<crate::models::SparkInvoiceFields>>::sse_encode(
            self.spark_invoice_fields,
            serializer,
        );
        <Option<String>>::sse_encode(self.signature, serializer);
    }
}

impl SseEncode for crate::models::SparkAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::SparkAddress>::sse_encode(self.decoded_address, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::SparkAddressPaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SparkAddressPaymentType::TokensPayment(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::models::TokensPaymentDetails>::sse_encode(field0, serializer);
            }
            crate::models::SparkAddressPaymentType::SatsPayment(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::models::SatsPaymentDetails>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SparkInvoiceFields {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.version, serializer);
        <Option<String>>::sse_encode(self.memo, serializer);
        <Option<String>>::sse_encode(self.sender_public_key, serializer);
        <Option<u64>>::sse_encode(self.expiry_time, serializer);
        <Option<crate::models::SparkAddressPaymentType>>::sse_encode(self.payment_type, serializer);
    }
}

impl SseEncode for crate::models::SuccessAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SuccessAction::Aes { data } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessAction::Message { data } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::MessageSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessAction::Url { data } => {
                <i32>::sse_encode(2, serializer);
                <crate::models::UrlSuccessActionData>::sse_encode(data, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SuccessActionProcessed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SuccessActionProcessed::Aes { result } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionDataResult>::sse_encode(result, serializer);
            }
            crate::models::SuccessActionProcessed::Message { data } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::MessageSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessActionProcessed::Url { data } => {
                <i32>::sse_encode(2, serializer);
                <crate::models::UrlSuccessActionData>::sse_encode(data, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Symbol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.grapheme, serializer);
        <Option<String>>::sse_encode(self.template, serializer);
        <Option<bool>>::sse_encode(self.rtl, serializer);
        <Option<u32>>::sse_encode(self.position, serializer);
    }
}

impl SseEncode for crate::models::SyncWalletRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::SyncWalletResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::TokenBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.balance, serializer);
        <crate::models::TokenMetadata>::sse_encode(self.token_metadata, serializer);
    }
}

impl SseEncode for crate::models::TokenMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.identifier, serializer);
        <String>::sse_encode(self.issuer_public_key, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.ticker, serializer);
        <u32>::sse_encode(self.decimals, serializer);
        <u128>::sse_encode(self.max_supply, serializer);
        <bool>::sse_encode(self.is_freezable, serializer);
    }
}

impl SseEncode for crate::models::TokensPaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.token_identifier, serializer);
        <Option<u128>>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::UrlSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.url, serializer);
        <bool>::sse_encode(self.matches_callback_domain, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::models::WaitForPaymentIdentifier {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::WaitForPaymentIdentifier::PaymentId(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::models::WaitForPaymentIdentifier::PaymentRequest(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::WaitForPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::WaitForPaymentIdentifier>::sse_encode(self.identifier, serializer);
    }
}

impl SseEncode for crate::models::WaitForPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use crate::sdk::*;
    use crate::sdk_builder::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Storage >>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Storage >>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBreezSdk(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBreezSdk(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
