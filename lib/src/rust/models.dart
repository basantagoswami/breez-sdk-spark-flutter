// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'errors.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `PaymentMetadata`, `UpdateDepositPayload`

class AesSuccessActionData {
  final String description;
  final String ciphertext;
  final String iv;

  const AesSuccessActionData({required this.description, required this.ciphertext, required this.iv});

  @override
  int get hashCode => description.hashCode ^ ciphertext.hashCode ^ iv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          ciphertext == other.ciphertext &&
          iv == other.iv;
}

class AesSuccessActionDataDecrypted {
  final String description;
  final String plaintext;

  const AesSuccessActionDataDecrypted({required this.description, required this.plaintext});

  @override
  int get hashCode => description.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionDataDecrypted &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          plaintext == other.plaintext;
}

@freezed
sealed class AesSuccessActionDataResult with _$AesSuccessActionDataResult {
  const AesSuccessActionDataResult._();

  const factory AesSuccessActionDataResult.decrypted({required AesSuccessActionDataDecrypted data}) =
      AesSuccessActionDataResult_Decrypted;
  const factory AesSuccessActionDataResult.errorStatus({required String reason}) =
      AesSuccessActionDataResult_ErrorStatus;
}

@freezed
sealed class Amount with _$Amount {
  const Amount._();

  const factory Amount.bitcoin({required BigInt amountMsat}) = Amount_Bitcoin;
  const factory Amount.currency({required String iso4217Code, required BigInt fractionalAmount}) =
      Amount_Currency;
}

class Bip21Details {
  final BigInt? amountSat;
  final String? assetId;
  final String uri;
  final List<Bip21Extra> extras;
  final String? label;
  final String? message;
  final List<InputType> paymentMethods;

  const Bip21Details({
    this.amountSat,
    this.assetId,
    required this.uri,
    required this.extras,
    this.label,
    this.message,
    required this.paymentMethods,
  });

  @override
  int get hashCode =>
      amountSat.hashCode ^
      assetId.hashCode ^
      uri.hashCode ^
      extras.hashCode ^
      label.hashCode ^
      message.hashCode ^
      paymentMethods.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip21Details &&
          runtimeType == other.runtimeType &&
          amountSat == other.amountSat &&
          assetId == other.assetId &&
          uri == other.uri &&
          extras == other.extras &&
          label == other.label &&
          message == other.message &&
          paymentMethods == other.paymentMethods;
}

class Bip21Extra {
  final String key;
  final String value;

  const Bip21Extra({required this.key, required this.value});

  @override
  int get hashCode => key.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip21Extra && runtimeType == other.runtimeType && key == other.key && value == other.value;
}

class BitcoinAddressDetails {
  final String address;
  final BitcoinNetwork network;
  final PaymentRequestSource source;

  const BitcoinAddressDetails({required this.address, required this.network, required this.source});

  @override
  int get hashCode => address.hashCode ^ network.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BitcoinAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          source == other.source;
}

enum BitcoinNetwork { bitcoin, testnet3, testnet4, signet, regtest }

class Bolt11Invoice {
  final String bolt11;
  final PaymentRequestSource source;

  const Bolt11Invoice({required this.bolt11, required this.source});

  @override
  int get hashCode => bolt11.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11Invoice &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          source == other.source;
}

class Bolt11InvoiceDetails {
  final BigInt? amountMsat;
  final String? description;
  final String? descriptionHash;
  final BigInt expiry;
  final Bolt11Invoice invoice;
  final BigInt minFinalCltvExpiryDelta;
  final BitcoinNetwork network;
  final String payeePubkey;
  final String paymentHash;
  final String paymentSecret;
  final List<Bolt11RouteHint> routingHints;
  final BigInt timestamp;

  const Bolt11InvoiceDetails({
    this.amountMsat,
    this.description,
    this.descriptionHash,
    required this.expiry,
    required this.invoice,
    required this.minFinalCltvExpiryDelta,
    required this.network,
    required this.payeePubkey,
    required this.paymentHash,
    required this.paymentSecret,
    required this.routingHints,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      amountMsat.hashCode ^
      description.hashCode ^
      descriptionHash.hashCode ^
      expiry.hashCode ^
      invoice.hashCode ^
      minFinalCltvExpiryDelta.hashCode ^
      network.hashCode ^
      payeePubkey.hashCode ^
      paymentHash.hashCode ^
      paymentSecret.hashCode ^
      routingHints.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11InvoiceDetails &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          description == other.description &&
          descriptionHash == other.descriptionHash &&
          expiry == other.expiry &&
          invoice == other.invoice &&
          minFinalCltvExpiryDelta == other.minFinalCltvExpiryDelta &&
          network == other.network &&
          payeePubkey == other.payeePubkey &&
          paymentHash == other.paymentHash &&
          paymentSecret == other.paymentSecret &&
          routingHints == other.routingHints &&
          timestamp == other.timestamp;
}

class Bolt11RouteHint {
  final List<Bolt11RouteHintHop> hops;

  const Bolt11RouteHint({required this.hops});

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11RouteHint && runtimeType == other.runtimeType && hops == other.hops;
}

class Bolt11RouteHintHop {
  final String srcNodeId;
  final String shortChannelId;
  final int feesBaseMsat;
  final int feesProportionalMillionths;
  final int cltvExpiryDelta;
  final BigInt? htlcMinimumMsat;
  final BigInt? htlcMaximumMsat;

  const Bolt11RouteHintHop({
    required this.srcNodeId,
    required this.shortChannelId,
    required this.feesBaseMsat,
    required this.feesProportionalMillionths,
    required this.cltvExpiryDelta,
    this.htlcMinimumMsat,
    this.htlcMaximumMsat,
  });

  @override
  int get hashCode =>
      srcNodeId.hashCode ^
      shortChannelId.hashCode ^
      feesBaseMsat.hashCode ^
      feesProportionalMillionths.hashCode ^
      cltvExpiryDelta.hashCode ^
      htlcMinimumMsat.hashCode ^
      htlcMaximumMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11RouteHintHop &&
          runtimeType == other.runtimeType &&
          srcNodeId == other.srcNodeId &&
          shortChannelId == other.shortChannelId &&
          feesBaseMsat == other.feesBaseMsat &&
          feesProportionalMillionths == other.feesProportionalMillionths &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          htlcMinimumMsat == other.htlcMinimumMsat &&
          htlcMaximumMsat == other.htlcMaximumMsat;
}

class Bolt12Invoice {
  final String invoice;
  final PaymentRequestSource source;

  const Bolt12Invoice({required this.invoice, required this.source});

  @override
  int get hashCode => invoice.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12Invoice &&
          runtimeType == other.runtimeType &&
          invoice == other.invoice &&
          source == other.source;
}

class Bolt12InvoiceDetails {
  final BigInt amountMsat;
  final Bolt12Invoice invoice;

  const Bolt12InvoiceDetails({required this.amountMsat, required this.invoice});

  @override
  int get hashCode => amountMsat.hashCode ^ invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12InvoiceDetails &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          invoice == other.invoice;
}

class Bolt12InvoiceRequestDetails {
  const Bolt12InvoiceRequestDetails();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is Bolt12InvoiceRequestDetails && runtimeType == other.runtimeType;
}

class Bolt12Offer {
  final String offer;
  final PaymentRequestSource source;

  const Bolt12Offer({required this.offer, required this.source});

  @override
  int get hashCode => offer.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12Offer &&
          runtimeType == other.runtimeType &&
          offer == other.offer &&
          source == other.source;
}

class Bolt12OfferBlindedPath {
  final List<String> blindedHops;

  const Bolt12OfferBlindedPath({required this.blindedHops});

  @override
  int get hashCode => blindedHops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12OfferBlindedPath && runtimeType == other.runtimeType && blindedHops == other.blindedHops;
}

class Bolt12OfferDetails {
  final BigInt? absoluteExpiry;
  final List<String> chains;
  final String? description;
  final String? issuer;
  final Amount? minAmount;
  final Bolt12Offer offer;
  final List<Bolt12OfferBlindedPath> paths;
  final String? signingPubkey;

  const Bolt12OfferDetails({
    this.absoluteExpiry,
    required this.chains,
    this.description,
    this.issuer,
    this.minAmount,
    required this.offer,
    required this.paths,
    this.signingPubkey,
  });

  @override
  int get hashCode =>
      absoluteExpiry.hashCode ^
      chains.hashCode ^
      description.hashCode ^
      issuer.hashCode ^
      minAmount.hashCode ^
      offer.hashCode ^
      paths.hashCode ^
      signingPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12OfferDetails &&
          runtimeType == other.runtimeType &&
          absoluteExpiry == other.absoluteExpiry &&
          chains == other.chains &&
          description == other.description &&
          issuer == other.issuer &&
          minAmount == other.minAmount &&
          offer == other.offer &&
          paths == other.paths &&
          signingPubkey == other.signingPubkey;
}

class ClaimDepositRequest {
  final String txid;
  final int vout;
  final Fee? maxFee;

  const ClaimDepositRequest({required this.txid, required this.vout, this.maxFee});

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode ^ maxFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositRequest &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          maxFee == other.maxFee;
}

class ClaimDepositResponse {
  final Payment payment;

  const ClaimDepositResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class Config {
  final String? apiKey;
  final Network network;
  final int syncIntervalSecs;
  final Fee? maxDepositClaimFee;

  const Config({this.apiKey, required this.network, required this.syncIntervalSecs, this.maxDepositClaimFee});

  @override
  int get hashCode =>
      apiKey.hashCode ^ network.hashCode ^ syncIntervalSecs.hashCode ^ maxDepositClaimFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          network == other.network &&
          syncIntervalSecs == other.syncIntervalSecs &&
          maxDepositClaimFee == other.maxDepositClaimFee;
}

class ConnectRequest {
  final Config config;
  final String mnemonic;
  final String storageDir;

  const ConnectRequest({required this.config, required this.mnemonic, required this.storageDir});

  @override
  int get hashCode => config.hashCode ^ mnemonic.hashCode ^ storageDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          mnemonic == other.mnemonic &&
          storageDir == other.storageDir;
}

class Credentials {
  final String username;
  final String password;

  const Credentials({required this.username, required this.password});

  @override
  int get hashCode => username.hashCode ^ password.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Credentials &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          password == other.password;
}

class DepositInfo {
  final String txid;
  final int vout;
  final BigInt amountSats;
  final String? refundTx;
  final String? refundTxId;
  final DepositClaimError? claimError;

  const DepositInfo({
    required this.txid,
    required this.vout,
    required this.amountSats,
    this.refundTx,
    this.refundTxId,
    this.claimError,
  });

  @override
  int get hashCode =>
      txid.hashCode ^
      vout.hashCode ^
      amountSats.hashCode ^
      refundTx.hashCode ^
      refundTxId.hashCode ^
      claimError.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DepositInfo &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          amountSats == other.amountSats &&
          refundTx == other.refundTx &&
          refundTxId == other.refundTxId &&
          claimError == other.claimError;
}

@freezed
sealed class Fee with _$Fee {
  const Fee._();

  const factory Fee.fixed({required BigInt amount}) = Fee_Fixed;
  const factory Fee.rate({required BigInt satPerVbyte}) = Fee_Rate;
}

class GetInfoRequest {
  const GetInfoRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is GetInfoRequest && runtimeType == other.runtimeType;
}

class GetInfoResponse {
  final BigInt balanceSats;

  const GetInfoResponse({required this.balanceSats});

  @override
  int get hashCode => balanceSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoResponse && runtimeType == other.runtimeType && balanceSats == other.balanceSats;
}

class GetPaymentRequest {
  final String paymentId;

  const GetPaymentRequest({required this.paymentId});

  @override
  int get hashCode => paymentId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentRequest && runtimeType == other.runtimeType && paymentId == other.paymentId;
}

class GetPaymentResponse {
  final Payment payment;

  const GetPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

@freezed
sealed class InputType with _$InputType {
  const InputType._();

  const factory InputType.bitcoinAddress(BitcoinAddressDetails field0) = InputType_BitcoinAddress;
  const factory InputType.bolt11Invoice(Bolt11InvoiceDetails field0) = InputType_Bolt11Invoice;
  const factory InputType.bolt12Invoice(Bolt12InvoiceDetails field0) = InputType_Bolt12Invoice;
  const factory InputType.bolt12Offer(Bolt12OfferDetails field0) = InputType_Bolt12Offer;
  const factory InputType.lightningAddress(LightningAddressDetails field0) = InputType_LightningAddress;
  const factory InputType.lnurlPay(LnurlPayRequestDetails field0) = InputType_LnurlPay;
  const factory InputType.silentPaymentAddress(SilentPaymentAddressDetails field0) =
      InputType_SilentPaymentAddress;
  const factory InputType.lnurlAuth(LnurlAuthRequestDetails field0) = InputType_LnurlAuth;
  const factory InputType.url(String field0) = InputType_Url;
  const factory InputType.bip21(Bip21Details field0) = InputType_Bip21;
  const factory InputType.bolt12InvoiceRequest(Bolt12InvoiceRequestDetails field0) =
      InputType_Bolt12InvoiceRequest;
  const factory InputType.lnurlWithdraw(LnurlWithdrawRequestDetails field0) = InputType_LnurlWithdraw;
  const factory InputType.sparkAddress(SparkAddressDetails field0) = InputType_SparkAddress;
}

class LightningAddressDetails {
  final String address;
  final LnurlPayRequestDetails payRequest;

  const LightningAddressDetails({required this.address, required this.payRequest});

  @override
  int get hashCode => address.hashCode ^ payRequest.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightningAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          payRequest == other.payRequest;
}

class ListPaymentsRequest {
  final int? offset;
  final int? limit;

  const ListPaymentsRequest({this.offset, this.limit});

  @override
  int get hashCode => offset.hashCode ^ limit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          limit == other.limit;
}

class ListPaymentsResponse {
  final List<Payment> payments;

  const ListPaymentsResponse({required this.payments});

  @override
  int get hashCode => payments.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsResponse && runtimeType == other.runtimeType && payments == other.payments;
}

class ListUnclaimedDepositsRequest {
  const ListUnclaimedDepositsRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is ListUnclaimedDepositsRequest && runtimeType == other.runtimeType;
}

class ListUnclaimedDepositsResponse {
  final List<DepositInfo> deposits;

  const ListUnclaimedDepositsResponse({required this.deposits});

  @override
  int get hashCode => deposits.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListUnclaimedDepositsResponse &&
          runtimeType == other.runtimeType &&
          deposits == other.deposits;
}

class LnurlAuthRequestDetails {
  final String k1;
  final String? action;
  final String domain;
  final String url;

  const LnurlAuthRequestDetails({required this.k1, this.action, required this.domain, required this.url});

  @override
  int get hashCode => k1.hashCode ^ action.hashCode ^ domain.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlAuthRequestDetails &&
          runtimeType == other.runtimeType &&
          k1 == other.k1 &&
          action == other.action &&
          domain == other.domain &&
          url == other.url;
}

class LnurlPayInfo {
  final String? lnAddress;
  final String? comment;
  final String? domain;
  final String? metadata;
  final SuccessActionProcessed? processedSuccessAction;
  final SuccessAction? rawSuccessAction;

  const LnurlPayInfo({
    this.lnAddress,
    this.comment,
    this.domain,
    this.metadata,
    this.processedSuccessAction,
    this.rawSuccessAction,
  });

  @override
  int get hashCode =>
      lnAddress.hashCode ^
      comment.hashCode ^
      domain.hashCode ^
      metadata.hashCode ^
      processedSuccessAction.hashCode ^
      rawSuccessAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayInfo &&
          runtimeType == other.runtimeType &&
          lnAddress == other.lnAddress &&
          comment == other.comment &&
          domain == other.domain &&
          metadata == other.metadata &&
          processedSuccessAction == other.processedSuccessAction &&
          rawSuccessAction == other.rawSuccessAction;
}

class LnurlPayRequest {
  final PrepareLnurlPayResponse prepareResponse;

  const LnurlPayRequest({required this.prepareResponse});

  @override
  int get hashCode => prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse;
}

class LnurlPayRequestDetails {
  final String callback;
  final BigInt minSendable;
  final BigInt maxSendable;
  final String metadataStr;
  final int commentAllowed;
  final String domain;
  final String url;
  final String? address;
  final bool allowsNostr;
  final String? nostrPubkey;

  const LnurlPayRequestDetails({
    required this.callback,
    required this.minSendable,
    required this.maxSendable,
    required this.metadataStr,
    required this.commentAllowed,
    required this.domain,
    required this.url,
    this.address,
    required this.allowsNostr,
    this.nostrPubkey,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      minSendable.hashCode ^
      maxSendable.hashCode ^
      metadataStr.hashCode ^
      commentAllowed.hashCode ^
      domain.hashCode ^
      url.hashCode ^
      address.hashCode ^
      allowsNostr.hashCode ^
      nostrPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequestDetails &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          minSendable == other.minSendable &&
          maxSendable == other.maxSendable &&
          metadataStr == other.metadataStr &&
          commentAllowed == other.commentAllowed &&
          domain == other.domain &&
          url == other.url &&
          address == other.address &&
          allowsNostr == other.allowsNostr &&
          nostrPubkey == other.nostrPubkey;
}

class LnurlPayResponse {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnurlPayResponse({required this.payment, this.successAction});

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayResponse &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

class LnurlWithdrawRequestDetails {
  final String callback;
  final String k1;
  final String defaultDescription;
  final BigInt minWithdrawable;
  final BigInt maxWithdrawable;

  const LnurlWithdrawRequestDetails({
    required this.callback,
    required this.k1,
    required this.defaultDescription,
    required this.minWithdrawable,
    required this.maxWithdrawable,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      k1.hashCode ^
      defaultDescription.hashCode ^
      minWithdrawable.hashCode ^
      maxWithdrawable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlWithdrawRequestDetails &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          k1 == other.k1 &&
          defaultDescription == other.defaultDescription &&
          minWithdrawable == other.minWithdrawable &&
          maxWithdrawable == other.maxWithdrawable;
}

class MessageSuccessActionData {
  final String message;

  const MessageSuccessActionData({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageSuccessActionData && runtimeType == other.runtimeType && message == other.message;
}

enum Network { mainnet, regtest }

class Payment {
  final String id;
  final PaymentType paymentType;
  final PaymentStatus status;
  final BigInt amount;
  final BigInt fees;
  final BigInt timestamp;
  final PaymentMethod method;
  final PaymentDetails? details;

  const Payment({
    required this.id,
    required this.paymentType,
    required this.status,
    required this.amount,
    required this.fees,
    required this.timestamp,
    required this.method,
    this.details,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      paymentType.hashCode ^
      status.hashCode ^
      amount.hashCode ^
      fees.hashCode ^
      timestamp.hashCode ^
      method.hashCode ^
      details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          paymentType == other.paymentType &&
          status == other.status &&
          amount == other.amount &&
          fees == other.fees &&
          timestamp == other.timestamp &&
          method == other.method &&
          details == other.details;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  const factory PaymentDetails.spark() = PaymentDetails_Spark;
  const factory PaymentDetails.lightning({
    String? description,
    String? preimage,
    required String invoice,
    required String paymentHash,
    required String destinationPubkey,
    LnurlPayInfo? lnurlPayInfo,
  }) = PaymentDetails_Lightning;
  const factory PaymentDetails.withdraw({required String txId}) = PaymentDetails_Withdraw;
  const factory PaymentDetails.deposit({required String txId}) = PaymentDetails_Deposit;
}

enum PaymentMethod { lightning, spark, deposit, withdraw, unknown }

class PaymentRequestSource {
  final String? bip21Uri;
  final String? bip353Address;

  const PaymentRequestSource({this.bip21Uri, this.bip353Address});

  @override
  int get hashCode => bip21Uri.hashCode ^ bip353Address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentRequestSource &&
          runtimeType == other.runtimeType &&
          bip21Uri == other.bip21Uri &&
          bip353Address == other.bip353Address;
}

enum PaymentStatus { completed, pending, failed }

enum PaymentType { send, receive }

class PrepareLnurlPayRequest {
  final BigInt amountSats;
  final LnurlPayRequestDetails payRequest;
  final String? comment;
  final bool? validateSuccessActionUrl;

  const PrepareLnurlPayRequest({
    required this.amountSats,
    required this.payRequest,
    this.comment,
    this.validateSuccessActionUrl,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^ payRequest.hashCode ^ comment.hashCode ^ validateSuccessActionUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayRequest &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          payRequest == other.payRequest &&
          comment == other.comment &&
          validateSuccessActionUrl == other.validateSuccessActionUrl;
}

class PrepareLnurlPayResponse {
  final BigInt amountSats;
  final String? comment;
  final LnurlPayRequestDetails payRequest;
  final BigInt feeSats;
  final Bolt11InvoiceDetails invoiceDetails;
  final SuccessAction? successAction;

  const PrepareLnurlPayResponse({
    required this.amountSats,
    this.comment,
    required this.payRequest,
    required this.feeSats,
    required this.invoiceDetails,
    this.successAction,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^
      comment.hashCode ^
      payRequest.hashCode ^
      feeSats.hashCode ^
      invoiceDetails.hashCode ^
      successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayResponse &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          comment == other.comment &&
          payRequest == other.payRequest &&
          feeSats == other.feeSats &&
          invoiceDetails == other.invoiceDetails &&
          successAction == other.successAction;
}

@freezed
sealed class ReceivePaymentMethod with _$ReceivePaymentMethod {
  const ReceivePaymentMethod._();

  const factory ReceivePaymentMethod.sparkAddress() = ReceivePaymentMethod_SparkAddress;
  const factory ReceivePaymentMethod.bitcoinAddress() = ReceivePaymentMethod_BitcoinAddress;
  const factory ReceivePaymentMethod.bolt11Invoice({required String description, BigInt? amountSats}) =
      ReceivePaymentMethod_Bolt11Invoice;
}

class ReceivePaymentRequest {
  final ReceivePaymentMethod paymentMethod;

  const ReceivePaymentRequest({required this.paymentMethod});

  @override
  int get hashCode => paymentMethod.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod;
}

class ReceivePaymentResponse {
  final String paymentRequest;
  final BigInt feeSats;

  const ReceivePaymentResponse({required this.paymentRequest, required this.feeSats});

  @override
  int get hashCode => paymentRequest.hashCode ^ feeSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          feeSats == other.feeSats;
}

class RefundDepositRequest {
  final String txid;
  final int vout;
  final String destinationAddress;
  final Fee fee;

  const RefundDepositRequest({
    required this.txid,
    required this.vout,
    required this.destinationAddress,
    required this.fee,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode ^ destinationAddress.hashCode ^ fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundDepositRequest &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          destinationAddress == other.destinationAddress &&
          fee == other.fee;
}

class RefundDepositResponse {
  final String txId;
  final String txHex;

  const RefundDepositResponse({required this.txId, required this.txHex});

  @override
  int get hashCode => txId.hashCode ^ txHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundDepositResponse &&
          runtimeType == other.runtimeType &&
          txId == other.txId &&
          txHex == other.txHex;
}

class SatsPaymentDetails {
  final BigInt? amount;

  const SatsPaymentDetails({this.amount});

  @override
  int get hashCode => amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SatsPaymentDetails && runtimeType == other.runtimeType && amount == other.amount;
}

class SilentPaymentAddressDetails {
  final String address;
  final BitcoinNetwork network;
  final PaymentRequestSource source;

  const SilentPaymentAddressDetails({required this.address, required this.network, required this.source});

  @override
  int get hashCode => address.hashCode ^ network.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SilentPaymentAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          source == other.source;
}

class SparkAddress {
  final String identityPublicKey;
  final BitcoinNetwork network;
  final SparkInvoiceFields? sparkInvoiceFields;
  final String? signature;

  const SparkAddress({
    required this.identityPublicKey,
    required this.network,
    this.sparkInvoiceFields,
    this.signature,
  });

  @override
  int get hashCode =>
      identityPublicKey.hashCode ^ network.hashCode ^ sparkInvoiceFields.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkAddress &&
          runtimeType == other.runtimeType &&
          identityPublicKey == other.identityPublicKey &&
          network == other.network &&
          sparkInvoiceFields == other.sparkInvoiceFields &&
          signature == other.signature;
}

class SparkAddressDetails {
  final String address;
  final SparkAddress decodedAddress;
  final PaymentRequestSource source;

  const SparkAddressDetails({required this.address, required this.decodedAddress, required this.source});

  @override
  int get hashCode => address.hashCode ^ decodedAddress.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          decodedAddress == other.decodedAddress &&
          source == other.source;
}

@freezed
sealed class SparkAddressPaymentType with _$SparkAddressPaymentType {
  const SparkAddressPaymentType._();

  const factory SparkAddressPaymentType.tokensPayment(TokensPaymentDetails field0) =
      SparkAddressPaymentType_TokensPayment;
  const factory SparkAddressPaymentType.satsPayment(SatsPaymentDetails field0) =
      SparkAddressPaymentType_SatsPayment;
}

class SparkInvoiceFields {
  final String id;
  final int version;
  final String? memo;
  final String? senderPublicKey;
  final BigInt? expiryTime;
  final SparkAddressPaymentType? paymentType;

  const SparkInvoiceFields({
    required this.id,
    required this.version,
    this.memo,
    this.senderPublicKey,
    this.expiryTime,
    this.paymentType,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      version.hashCode ^
      memo.hashCode ^
      senderPublicKey.hashCode ^
      expiryTime.hashCode ^
      paymentType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkInvoiceFields &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          version == other.version &&
          memo == other.memo &&
          senderPublicKey == other.senderPublicKey &&
          expiryTime == other.expiryTime &&
          paymentType == other.paymentType;
}

@freezed
sealed class SuccessAction with _$SuccessAction {
  const SuccessAction._();

  const factory SuccessAction.aes({required AesSuccessActionData data}) = SuccessAction_Aes;
  const factory SuccessAction.message({required MessageSuccessActionData data}) = SuccessAction_Message;
  const factory SuccessAction.url({required UrlSuccessActionData data}) = SuccessAction_Url;
}

@freezed
sealed class SuccessActionProcessed with _$SuccessActionProcessed {
  const SuccessActionProcessed._();

  const factory SuccessActionProcessed.aes({required AesSuccessActionDataResult result}) =
      SuccessActionProcessed_Aes;
  const factory SuccessActionProcessed.message({required MessageSuccessActionData data}) =
      SuccessActionProcessed_Message;
  const factory SuccessActionProcessed.url({required UrlSuccessActionData data}) = SuccessActionProcessed_Url;
}

class SyncWalletRequest {
  const SyncWalletRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletRequest && runtimeType == other.runtimeType;
}

class SyncWalletResponse {
  const SyncWalletResponse();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletResponse && runtimeType == other.runtimeType;
}

class TokensPaymentDetails {
  final String? tokenIdentifier;
  final BigInt? amount;

  const TokensPaymentDetails({this.tokenIdentifier, this.amount});

  @override
  int get hashCode => tokenIdentifier.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokensPaymentDetails &&
          runtimeType == other.runtimeType &&
          tokenIdentifier == other.tokenIdentifier &&
          amount == other.amount;
}

class UrlSuccessActionData {
  final String description;
  final String url;
  final bool matchesCallbackDomain;

  const UrlSuccessActionData({
    required this.description,
    required this.url,
    required this.matchesCallbackDomain,
  });

  @override
  int get hashCode => description.hashCode ^ url.hashCode ^ matchesCallbackDomain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UrlSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          url == other.url &&
          matchesCallbackDomain == other.matchesCallbackDomain;
}
